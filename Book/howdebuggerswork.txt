# How Visual C++'s debugger works {#how-visual-debugger-works}

This will bring your debugging knowledge and experience to a level where
breakpoints are no longer this magical thing that works for mysterious
reasons. Your program's behavior when running within the debugger will be
easier to understand. What are the threads running when my program hits a
breakpoint? Why are my local variables initialized to _0xCC_ when running the
"Debug" build? At the end, you'll be able to answer these questions and many
others.

## Debugger and debuggee relationship

## Writing our own debugger

## How basic breakpoints work {#how-location-breakpoints-work}

Location breakpoints are implemented with a specific CPU instruction: _INT 3_
(for INTerrupt number 3). It is also called the _breakpoint exception
interruption_. When the debuggee executes this instruction, the CPU calls a
specific handler previously setup by the operating system. This handler:

1. Saves the state of the debuggee and pauses it. 
2. If a debugger is attached to the debuggee, the system notifies the debugger 
process that its debuggee triggered a breakpoint by generating a _debug event_.
3. If there's no debugger watching the debuggee's process, the system generates
a breakpoint exception. If the debuggee doesn't handle the breakpoint exception,
it will abort its execution.

Programmers can trigger the breakpoint exception interruption directly in their
code to add breakpoints programmatically. To try it for yourself, open the
_Breakpoints_ project and set it as the startup project. Then, open up the
_main.cpp_ file in the text editor. Make sure that no location breakpoint is
set (no red disk is visible on the left side of the source code in the code
editor), and start debugging the program by pressing F5.

Although no breakpoint has been set in Visual C++'s IDE, the debugger will
break on the call to _\_\_debugbreak_.

![The debugger breaks on the _\_\_debugbreak_ instruction although no breakpoint has been set.](images/hardcoded-breakpoint-triggered.png)

Now, toggle the disassembly window by pressing Alt + 8. The yellow arrow
points to the code generated by the compilation of _\_\_debugbreak_.
Unsurprisingly, the disassembler shows that the compiler generated an _INT 3_
instruction:

![_\_\_debugbreak_ has been compiled to an _INT 3_ instruction.](images/hardcoded-breakpoint-disassembly.png)

[There are several ways to set breakpoints programmatically](#setting-breakpoints-programmatically).
It can sometimes be the right tool for the job. However, having to change the source code of the
debuggee every time a new breakpoint is needed is counter productive, as it requires the
debugging session to be restarted from scratch[^unless-edit-and-continue].

[^unless-edit-and-continue]: The "Edit & Continue" feature can be used to avoid restarting the debugging session, but it's not always an option. For instance, it doesn't work for optimized builds.

Luckily, there's another, more efficient way for a debugger to implement
location breakpoints. When the debugger launches the program to debug, it is
granted permissions to write to the memory area where the debuggee's code is
located. Then, it can change the debuggee's executable code so that it
executes _INT 3_ instructions at locations where the user set breakpoints.

It is actually possible to do this manually. We're going to use the debugger
to patch the debuggee's executable code and insert an _INT 3_ instruction
where we want it to break. With the same _Breakpoints_ project opened and set
as startup project, set a breakpoint on the first line of code in the _main_
function:

![Setting a breakpoint on _main_'s first line of code.](images/breakpoint-at-main-first-instruction-in-breakpoints-project.png)

Start debugging by pressing F5, the breakpoint will be hit. Show the
disassembly window by pressing Alt + 8. Toggle the memory window by pressing
ALt + 6 and copy the address of the instruction after the next instruction in
the assembly window to the address bar in the memory window. Finally, press
enter in the memory window's input field to validate your input:

![Examining the debuggee's executable code in the memory window.](images/breakpoint-assembly-and-memory-windows.png)

If instructions' addresses or code bytes do not show in the disassembly
window, make sure that the "Show Code Bytes" and "Show Address" options are
checked when right clicking in it.

We're going to do what the debugger does when setting a location breakpoint:
change the first byte of an instruction to be _0xCC_, the hexadecimal
representation of _INT 3_'s opcode. We'll change the first byte of the
instruction after the instruction pointed to by the yellow arrow, so that we
can actually verify that our change triggers a breakpoint by continuing the
debuggee's execution and checking that a breakpoint is hit.

Click in the memory window on the first byte at the top left, a grey cursor
should appear. Press the 'C' key twice on your keyboard to write INT 3's
opcode into the memory. Visual C++'s disassembly window should have updated
the assembly code with an _INT 3_ instruction to reflect your change:

![The disassembly and memory window after patching the code to add an INT 3 instruction.](images/breakpoint-assembly-and-memory-windows-after-patching-int3.png)

Now press F5, your newly added breakpoint should trigger:

![](images/patched-in-breakpoint-triggered.png)

Congratulations, you just patched some executable code live and added a
breakpoint manually!

The _INT 3_ instruction has actually been designed to be inserted by debuggers
into executable code. Its binary transcription is only one byte long, and can
thus be used to replace any other instruction, without corrupting the rest of
the code, like overwriting their operand or subsequent instructions.

But wait, why don't we see _INT 3_ instructions in the disassembly window when
we set a location breakpoint in the source code?

### Checking that Visual C++'s debugger actually uses INT 3 instructions to implement location breakpoints

Let's use the same _Breakpoints_ project that we used previously to verify
that software breakpoints are used by the debugger to implement location
breakpoints. Open the project in Visual C++ and set a breakpoint where _foo_
is assigned the value 0, at the beginning of the _main_ function:

![Setting a location breakpoint where _foo_ is assigned the value 0.](images/add-location-breakpoint-foo-assign.png)

Compile the project and start the debugger by pressing F5. The breakpoint
should be triggered.

![The location breakpoint is triggered.](images/location-breakpoint-foo-assign-hit.png)

Now, open up the disassembly window by pressing Alt + 8 to check that the
debugger actually patched the executable code where we set the location
breakpoint. Make sure that the "Show Code Bytes" and "Show Address" options
are checked when right clicking in the disassembly window.

![Make sure that addresses and code bytes are displayed in the disassembly window.](images/disassembly-right-click.png)

Surprisingly, the disassembly window doesn't show an _INT 3_ instruction, but
a _MOV_ instruction, which implements the assignation of the value 0 to the
_foo_ variable:

![The disassembly window doesn't show any INT 3 instruction where the location breakpoint was set.](images/location-breakpoint-disassembly.png)

Would Visual C++'s debugger hide some information from us? Let's verify this with the
_Memory_ window. Click on _DEBUG_ -> _Windows_ -> _Memory_ -> _Memory 1_ or
press Alt + 6. Copy the address where the location breakpoint is set and paste
it in the memory window's input field.

![Examining a location breakpoint's code with the memory window.](images/examine-location-breakpoint-code-in-memory-window.png)

At the top left corner of the memory window, the first byte stored at the
location breakpoint's adress is shown: _C7_. However, _C7_ is the hexadecimal
representation for a _MOV_ instruction's opcode, not an _INT 3_ instruction
which opcode is represented by _CC_ in hexadecimal notation.

Are we missing something or is Visual C++'s debugger lying to us again?
Let's find out by writing a simple program. This program takes a memory
address as input, reads one byte at this address and output its value. If a
location breakpoint is set at the address given as input, it should output the
value corresponding to _INT 3_'s opcode, _CC_.

Open up the _MemReader_ project and set it as your startup project. Open its
_main.cpp_ file in the text editor and set a location breakpoint before the
_while (true)_ loop:

![Setting a location breakpoint in the _MemReader_ project.](images/set-location-breakpoint-memreader-project.png)

Start debugging by pressing F5 and wait for the breakpoint to be hit. Bring up
the disassembly window by pressing Alt + 8 and copy the address where the
location breakpoint is set somewhere (for instance, in a notepad window).
Continue the execution by pressing F5 again, a prompt asking you to enter an
address should appear:

![_MemReader_ prompts for the memory address where the location breakpoint was set.](images/memreader-prompt.png)

Type in the address you copied previously and make sure it is prefixed with
_0x_, indicating that it's using an hexadecimal representation. Press enter,
the following message should appear:

    Data at address 0xf7a899: 0xcc
    Data at address 0xf7a899 IS a breakpoint opcode!

At last, we found the _INT 3_ instruction's binary code where a location
breakpoint has been set. In order to double check that _MemReader_ is not also
lying to us, let's disable the location breakpoint and see if it still detects
_INT 3_'s opcode. Display the _Breakpoints_ window by pressing Alt + F9 and
uncheck the checkbox on the line representing the location breakpoint. The
disk filled with red should become an empty red circle.

![Disabling the location breakpoint.](images/disable-location-breakpoint-memreader.png)

Now, enter the same address as before at _MemReader_'s prompt, then press
enter. The following message should be written:

    Data at address 0xf7a899: 0xf7a8990x68
    Data at address 0xf7a899 is NOT a breakpoint opcode!

Excellent, we just proved that Visual C++'s debugger hides how the debugger
patches the debuggee's executable code with _INT 3_ instructions.

The _INT 3_ instruction is called a _software breakpoint_ because it doesn't
rely on specific hardware. Programmers or debuggers just need to insert this
instruction into the debuggee's executable code where they want it to break.
There's no limit to the number of software breakpoints that can be set. This
is especially handy for location breakpoints because it is often necessary to
break at many different key places in the code to investigate issues. If there
was a limitation on the number of location breakpoints that could be set, it
would make debugging much more tedious.

On x86 and x86-64 architectures, there is another way to implement
breakpoints: _hardware breakpoints_. They are fundamentally different than
software breakpoints and have different use cases. Their usage and
implementation details are covered in [a later section of this chapter
entitled _Data breakpoints_ ](#data-breakpoints).

### Other uses of the INT 3 instruction

Because the INT 3 instruction is compiled to one byte of binary code, it's
also a very flexible tool to break into the debugger as soon as the program
executes code that should not be executed. 

#### Default value for uninitialized variables in unoptimized builds

When the _/RTC1_ (for "RunTime Checks") code generation option is enabled, the
Visual C++ compiler fills variables with the value _0xCC_.

To enable runtime checks, go the "Breakpoints" project properties by pressing
Alt + F7, then select "Configuration Properties" -> "C/C++" -> "Code
generation". Finally, set "Basic Runtime Checks" to "Both":

![Enabling runtime checks in the project properties dialog](images/basic-runtime-checks-settings.png)

Now set a breakpoint on the line of code where foo is assigned the value 0, at
the start of _main_'s implementation. Start debugging by pressing F5 and add
the variable foo to the watch window by using the ",x" format specifier.

![Unitialized variables are set to 0xCC when runtime checks are enabled.](images/basic-runtime-checks-unitialized-variable@300.png)

This default initialization is handy to detect variables that have not been
initialized when first used. With its specific pattern, it stands out from any
random value in the watch window. It's also used by the compiler to make sure
that buffer overflows or underflows did not occur during a function calls:
when the function exits, the compiler generates code that checks if data in
memory right before and after local variables still contains _0xCC_ bytes.

But why fill memory with _0xCC_? The compiler could choose to fill it with
NOPs intructions (0x90). 0xCC being the binary code for a breakpoint
exception, it allows the debuggee to trigger a breakpoint when uninitialized
data is used as executable code.

As mentioned before, the fact that the breakpoint exception instruction is
only one byte long makes it very flexible: variables of any size can be filled
with as many _INT 3_ instructions as necessary.

#### Fill instruction for padding areas of executable code

Another use of the _INT 3_ instruction is to pad the program's executable
code segment with instructions that trigger an exception that can be caught by a debugger. 

If the debugger is still paused where the breakpoint triggered, display the
disassembly window by pressing Alt + 8. Scroll up or down in the disassembly
window and you should see whole memory areas filled with _INT 3_ instructions.

![INT 3 instructions are also used to pad executable code.](images/int3-padding@300.png)

The compiler and linker usually generate executable code so that function
entry points are located on 16 or 32 bytes boundaries for performance
purposes. Any space that remains between actual executable code is padded.
Note that sometimes, other one byte instructions such as _NOP_ (0x90) can be
used for padding.

### Stepping

## How data breakpoints work under the hood {#how-data-breakpoints-work}

We presented earlier [how location breakpoints are implemented using _software
breakpoints_](#how-location-breakpoints-work). Using the _INT 3_ instruction
is well suited to trigger a breakpoint when an instruction at a given address
in the debuggee's code is executed. However, it can't be used to trigger a
breakpoint depending on some operation performed on the debuggee's data.

With data breakpoints, the CPU needs a way to know for which address(es) a
breakpoint exception needs to be raised when some memory operation is
performed. The most convenient and efficient way to store these addresses is
to use _debug registers_ on the CPU. This is why it is said that data
breakpoints are implemented with _hardware breakpoints_: they depend on actual
hardware. Because hardware is, by definition, finite and limited, data
breakpoints are [limited both in size and number](#data-breakpoints-size-and-number-limitation).

On x86 and x86-64 architectures, there are eight debug registers named _DR0_
to _DR7_.

_DR7_ is a debug control register that determines what conditions should
trigger a breakpoint exception:

* When a memory write is performed.
* When a memory read or a memory write is performed.
* When an instruction is executed.

Depending on the bits set in _DR7_, registers _DR0_ to _DR3_ have a different
meaning. If _DR7_ is set to trigger a breakpoint exception when a memory write
or read is performed, the content of _DR0_ to _DR3_ is used to determine for
which memory address written to or read from the exception should be raised.
If _DR7_ is set to trigger when an instruction is executed, memory addresses
in _DR0_ to _DR3_ are used to determine the addresses in the executable code
that should trigger the breakpoint when they are executed. It also determines
the size of the memory area to watch when the mode is set to break on memory
reads and/or writes. The size is stored as a two bits number but only sizes of
one, two and four bytes are supported on x86. On x86-64, data breakpoints of 8
bytes are also supported.

Hardware breakpoints could be used to implement location breakpoints since
they can trigger a breakpoint exception when a given instruction is executed.
However, that would limit programmers to use no more than four of them. The
_INT 3_ instruction is much better suited to implement location breakpoints,
since it doesn't suffer from this limitation. Thus, one mode of the _DR7_
register, breaking on instruction execution, is rarely used.

Depending on the content of the DE flag in CR4, _DR4_ and _DR5_ are either
aliases to _DR6_ and _DR7_, or their use would trigger an _invalid opcode_
excetion.

Finally, _DR6_ is a debug status register that reports the reason why a data
breakpoint triggered.

To see the data breakpoints' implementation in action with Visual C++'s
debugger, set the project named "HowDataBreakpoints" work as the startup
project and open its _main.cpp_ file in the code editor. Then, set a
breakpoint on the _while_ statement.

![Using the project named "HowDataBreakpointsWork" to illustrate data breakpoints' implementation.](images/how-data-breakpoints-work.png)

Start debugging the program and when the breakpoint is triggered, add a data
breakpoint by clicking on _DEBUG_ -> _New Breakpoint_ -> _New Data
Breakpoint..._. Enter an address that is easy to remember for the newly
created data breakpoint, the size is not important (as long as it's less or
equal than 4 bytes on x86, and less or equal than 8 bytes on x64). Now press
_F5_ to continue the debuggee's execution, you should hit the breakpoint again.
Press _Alt + Tab_ to display the program's output window: you should see the
address of your data breakpoint in the output. 

Continue adding/disabling/removing data breakpoints and see how it affects the
output.

## How Edit & Continue is implemented

## Resources

* The [Intel Architecture Software Developer manual](http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html), Volume 3, chapter 17. Contains in-depth documentation about how Intel CPUs support breakpoints.
* Section "INT n/INTO/INT 3-Call to Interrupt Procedure" of the [Intel Architecture Software Developer manual](http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html), Volume 2, Chapter 3, page 404. 






