<!DOCTYPE html>

<!--
  Google HTML5 slide template

  Authors: Luke Mahé (code)
           Marcin Wichary (code and design)
           
           Dominic Mazzoni (browser compatibility)
           Charles Chen (ChromeVox support)

  URL: http://code.google.com/p/html5slides/
-->

<html>
  <head>
    <title>Débogage avancé avec Visual C++ 2010</title>

    <meta charset='utf-8'>
    <script src='slides.js'></script>	  
  </head>
  
  <style>
    /* 
	Your individual styles here, or just use inline styles if that’s
    what you want. 
	*/
    
	q {
	display: inline;
	}
    
	ul {
	  list-style: none;
	  margin: 0;
	  padding: 0;

	  margin-top: 0;

	  margin-left: .75em;
	}
	
	.centered .syntaxhighlighter table,
	.centered .syntaxhighlighter table td,
	.centered .syntaxhighlighter table tbody,
	.centered .syntaxhighlighter table tr,
	.centered .syntaxhighlighter table thead,
	.centered .syntaxhighlighter table caption,
	.centered .syntaxhighlighter textarea,
	.centered .syntaxhighlighter code,
	.centered .syntaxhighlighter div
	{
		text-align: center !important
	}	
  </style>

  <body style='display: none'>	
	<div id='content'>
		<section class='nologo slides layout-regular template-default'>
		  
		  <article class='nologo'>
			<h1>
			  Débogage avancé                    
			</h1>
			<h3>
			  avec Visual C++ 2010 et Windows
			</h3>
			<p>
			  Julien Gilli :: julien.gilli@gmail.com			  
			</p>
		  </article>
		  
		  <article class='nologo'>
			<h3>Plan</h3>
			</br>
			</br>
			<div>
				<ul class="build">
					<li><b>Outils avancés de débogage dans Visual C++:</b>
						<table class="build noborder">					
							<tr>
								<td>Points d'arrêt</td><td><img src="img/breakpoint screenshot.png"</img></td>
							</tr>
							<tr>
								<td>Fenêtre d'inspection</td><td><img src="img/inspection window screenshot.png"</img></td>
							</tr>
							<tr>
								<td>Prochaine instruction</td><td><img src="img/next instruction screenshot.png"</img></td>
							</tr>
							<tr>
								<td>etc.</td><td></td>
							</tr>
						</table>
					<li><b>Démystifier le débogueur:</b>
						<table class="build noborder">
							<tr>
								<td>Différence debug/release</td><td><img src="img/build configuration screenshot.png"</img></td>
							</tr>
							<tr>
								<td>Débogage en assembleur</td><td><img src="img/desassembly screenshot.png"</img></td>
							</tr>						
						</table>
				</ul>		  			
			</div>
		  </article>
		
		 <article class='nologo'>
			<h1>
			  Outils avancés                    
			</h1>		
		 </article>
		  
			<article class='nologo'>		
				<h3>Points d'arrêt</h3>
				</br>
				</br>			
				<ul class='build'>
					<li>Points d'arrêt conditionnels.
					<li>Points de trace.
					<li>Points d'arrêts sur adresse mémoire: max 4, ASLR (> Vista seulement).
					<li>Arrêt en fonction du nombre d'occurence, etc.
					<li>Attention aux performances !
					<li>__asm int 3
					<li>Export/import, étiquettes.
				</ul>
			</article>			
					
			<article class='nologo'>		
				<h3>Inspection de valeurs</h3>
				</br>
				</br>
				<ul class='build'>
					<li>Transtypage de valeurs.
					<li>Arithmétique de pointeurs.
					<li>Conversion de formats.
					<li>Exécution de fonctions.
					<li>Calculatrice :)
					<li>Personalisation avec autoexp.dat.
				</ul>
			</article>
			
			<article class='nologo'>		
				<h3>Autres outils</h3>
				</br>
				</br>
				<ul class='build'>
					<li>Pointeur sur la prochaine instruction.
					<li>OutputDebugString/IsDebuggerPresent/etc. .
					<li>Threads: freeze et thaw, SetName.
					<li>Favoris.
					<li>Data tips.
				</ul>
			</article>
			
		<article class='nologo'>
			<h1>
			  Débogage de code optimisé                    
			</h1>		
		 </article>
		 
		 <article class='nologo'>
			<h3>Pourquoi c'est souvent nécessaire ?</h1>
			</br>
			</br>			
			<ul class='build'>
				<li>Les performances du programme en mode débug sont trop mauvaises (temps de chargement trop longs).
				<li>Le bug est reproductible seulement lorsque le code contient des optimisations (framerate dependant). 
				<li>Le code source n'est pas disponible.
			</ul>
		 </article>
		
		<article class='nologo'>
			<h3>Comment faire ?</h3>
			</br>
			</br>			
			<ul class='build'>
				<li>Briser le mythe "débogage seulement en configuration Debug".
				<li>Utiliser les symboles.
				<li>Maîtriser le désassembleur.
			</ul>
		</article>

		<article class='nologo'>
		<h3>Options de configuration</h3>
		</br>
		</br>			
		<ul class='build'>
			<li>Configurations par défaut.</li>
			<li>Compilation vs Liaison (code linking).</li>
			<li>Débogage vs Optimisation.</li>
		</ul>
		</article>

		<article class='nologo'>
			<h3>Symboles</h3>
			</br>
			</br>			
			<ul class='build'>
				<li>Générer les symboles, tout le temps.
				<li>Serveur de symboles.
				<li>Symboles système.
				<li>Stack walking et FPO.
				<li>Formats, API (DIA SDK).
				<li>Fenêtre 'modules'.
			</ul>
		</article>
		
		<article class='nologo'>
			<h3>Anatomie d'un programme en cours d'exécution</h1>
			</br>
			</br>			
			<ul class='build'>
				<li>Programme != Processus.
				<li>Organisation d'un processus en mémoire: code + données constantes + tas + pile.
				<li>On peut aussi voir le code comme...des données :)
			</ul>
		 </article>	 

		<article class='nologo'>
			<h3>Anatomie d'un programme en cours d'exécution</h1>
			</br>
			</br>			
			<img class='centered' src='img/process memory layout.png'></img>
		 </article>	 
		 
		<article class='nologo'>
			<h3>Fonctionnement d'un processus</h1>
			</br>
			</br>			
			<ul class='build'>
				<li>Lecture de l'instruction à l'adresse mémoire contenue dans EIP, décodage et exécution.
				<li>Entraîne modification de:
				<ul class='build'>
					<li>la mémoire: tas, pile ou données constantes ou...code.
					<li>un ou plusieurs registres.
				</ul>
			</ul>
		 </article>
		 
		 <article class='nologo'>
			<h3>Observons cela avec le débogueur</h1>
			</br>
			</br>			
			<ul class='build'>
				<li>Fenêtres "modules": où se trouve le code ?
				<li>Fenêtre "mémoire": où se trouvent les "données" ?
				<li>Fenêtre "registres".
			</ul>
		 </article>
			 
		 <article class='nologo'>
			<h3>Premier exemple</h1>
			</br>
			</br>			
			<ul class='build'>
				<li>En release, impossible d'ajouter un point d'arrêt ailleurs que sur le "return 0".
				<li>Valeurs présentes/absentes (debug/release) dans la fenêtre d'inspection des valeurs.
				<li>Le "Set next statement" (flèche jaune) ne fonctionne pas "correctement" en release.
			</ul>
		 </article>
		
		 <article class='nologo'>
			</br>
			</br>
			</br>
			</br>
			<q>Pourquoi ces différences ?</q>
		</article>
		
		 <article class='nologo'>
			<h3>Examinons le code assembleur généré pour comprendre !</h1>
			</br>
			</br>
			<ul class='build'>
				<li>Options de génération de code à desactiver: /GS et /RTCs.
				<li>Vue d'ensemble de la fenêtre de désassemblage: navigation, options.
				<li>Instructions de remplissage.
			</ul>
		 </article>
		 
		 <article class='nologo'>
			<h3>Deuxième exemple</h1>
			</br>
			</br>
			</br>
			<ul class='build'>
				<li>Comme pour l'exemple numéro 1, la plupart des points d'arrêts ne sont pas valides en mode Release.
				<li>Inlining de fonctions/méthodes.
				<li>Pourquoi utiliser des nombres aléatoires ?			
				<li>Emplacement en mémoire de la variable statique.
			</ul>
		 </article>		
		
		<article class='nologo'>
			<h2>
			  Fonctionnement bas niveau de quelques mécanismes courrants
			</h2>		
		 </article>
		
		<article class='nologo'>
			<h3>Affectations, initialisations, arithmétique</h1>
			</br>
			</br>
			</br>
			<ul class='build'>
				<li>MOV, ADD, SUB
				<li>Modes d'adressage: immédiat, registre, mémoire.
				<li>Effective address de la fenêtre "registres".
				<li>Sur x86 il n'est pas possible d'utiliser un accès mémoire/mémoire, besoin de passer par un registre intermédiaire.
			</ul>
		 </article>
		 
		 <article class='nologo'>
			<h3>Structures conditionnelles et itératives</h1>
			</br>
			</br>
			</br>
			<ul class='build'>
				<li>if, else, else if, for, while, etc.
				<li>JMP, JNE, J.., CMP			
			</ul>
		 </article>
		 
		 
		 <article class='nologo'>
			<h2>
			  Appels de fonctions
			</h2>		
		 </article>
		 
		 <article class='nologo'>
			<h3>
			  Description haut-niveau
			</h3>					
			</br>
			</br>		
			<img src='img/stack simple.png' class='centered'></img>
			<ul class='build'>
				<li>Pile, cadre de pile, contenu d'un cadre de pile.
				<li>Evolution de la pile au cours des appels, stack overflow.
			</ul>
		 </article>
		 
		 <article class='nologo'>
			<h3>
			  Description détaillée
			</h3>			
			
			</br>
			</br>
			<img src='img/stack detailed.png' class='centered'></img>
		 </article>
		 
		 <article class='nologo'>
			<h3>
			  Description détaillée
			</h3>			
			
			</br>
			</br>
			</br>
			<ul class='build'>
				<li>CALL, RET, PUSH, POP.
				<li>Accès aux paramètres + locales: EBP, ESP, FPO.
				<li>Conventions d'appel: cdecl, stdcall (aka WINAPI), this.
				<li>Pourquoi plusieurs conventions d'appel ?
				<li>Edit & Continue.
				<li>Appel de fonctions Vs appel de méthode Vs appel de méthode virtuelle.
			</ul>
		 </article>
			 
		 <article class='nologo'>
			<h3>
			  Informations fiables
			</h3>
			</br>
			</br>
			</br>
			<ul class='build'>
				<li>Layout d'une variable/instance: le compilateur ne peut pas optimiser le layout d'une structure.
				<li>vfptr: excellent indice pour savoir si l'on examine le bon type d'objet.
				<li>variables statiques/globales: toujours au meme emplacement mémoire.
				<li>La valeur de retour d'une méthode/fonction est toujours dans eax/ax/al.
			</ul>
		 </article>	 	 

		<article class='nologo'>
			<h3>
				Informations <b>pas</b> fiables
			</h3>
			</br>
			</br>
			</br>
			<ul class='build'>
				<li>Callstack: absence de symboles + FPO, inlining, etc.
				<li>Tooltip du débogueur, que ce soit en mode "source" ou "desassembleur".
				<li>Watch window pour les symboles de variables locales/paramètres.
			</ul>
		</article>	
		 
		 <article class='nologo'>
			<h3>
			  Autres astuces intéressantes
			</h3>
			</br>
			</br>
			</br>
			<ul class='build'>
				<li>Différence powerpc Vs X86: beaucoup plus de registres.
				<li>Comment déclencher un point d'arrêt selon l'appelant (EBP, ESP).
				<li>Comment modifier le code du programme *pendant* l'exécution (NOP).
				<li>#pragma optimize on/off.
				<li>Afficher les variables d'environnement: $env=0.
			</ul>
		 </article>
		 
		 <article class='nologo'>
			<h1>
			  Conclusion
			</h1>			
		 </article>	 	
		
		 <article class='nologo'>
			<h3>
			  Les sujets qui n'ont pas été traités
			</h3>
			</br>
			</br>
			</br>
			<ul class='build'>
				<li>Nombres flottants (registres/instructions/stack spécifiques)
				<li>Génération/utilisation de crash dumps.
				<li>Génération/utilisation de fichiers .map.
				<li>Débogage sur plateforme 64 bits...
			</ul>
		 </article>
		 
		 <article class='nologo'>
			<h3>
			  Pour aller plus loin
			</h3>
			</br>
			</br>
			</br>
			<ul class='build'>
				<li>"Debugging Applications" par John Robbins, Microsoft Press.
				<li>"Assembly Language For Intel-Based Computers", Kip R. Irvine, Pearson.
				<li>Intel Architecture Software Developer's Manual, en ligne à http://www.intel.com/.
			</ul>
		 </article>	      
		 
		 <article class='nologo'>
			<h1>
			  Merci !
			</h1>		
		 </article>
		
		<article class='nologo'>
			<h2>
			  Exercice
			</h3>			
					
		 </article>	 
		
		</section>	
	</div>
	
	<div id='footer' class='centered'>
		<a href='advanced_debugging_examples.rar'>Download examples' source code</a>
	</div>
	
  </body>
</html>
