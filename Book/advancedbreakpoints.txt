# Advanced breakpoints

Breakpoints are one of the most important tools when debugging a program
during development. They allow programmers to pause at any desired point in
their execution flow and investigate their state. Without breakpoints,
programmers would need to log information to some output device to understand
how a program behaves.

While relying on debug output logs to investigate an issue can be fine in some
situations, it is often inadequate. Large programs can take a very long time
to build and link. Using only debug output logs to debug programs requires
them to be built and linked every time a programmer wants to change the debug
output, making the process slow and frustrating. Moreover, writing debug
output code can change the debuggee's behavior such that bugs appear or
disappear.

Although it is very likely that you're already familiar with basic
breakpoints, this chapter starts by a very quick review of how to use them,
just to make sure that everyone is on the same page.

Next, their implementation is explained in details. This will bring your
debugging knowledge and experience to a level where breakpoints are no longer
this magical thing that works for mysterious reasons. Your program's behavior
when running within the debugger will be easier to understand. What are the
threads running when my program hits a breakpoint? Why are my local variables
initialized to _0xCC_ when running the "Debug" build? At the end, you'll be
able to answer these questions and many others.

Then, the focus will be on introducing two types of breakpoints that most
people don't know about: _conditional_ and _data_ or _memory_ breakpoints.
We'll show when they're most useful and how to use them. Conditional
breakpoints are implemented on top of basic breakpoints, but data breakpoints
work quite differently. Their implementation will also be explained in
details. We'll present their differences and show you how to combine these two
types of breakpoints to get even more powerful tools.

At the end of this chapter, not only will you have gained a new set of tools
to boost your productivity and your efficiency when debugging programs, you
will also know how they work at a very low level. This combination will make
you more productive and confident when using such fundamental debugging tools
as breakpoints.

## Basic breakpoints

Basic breakpoints are also called _location_ breakpoints because they are
triggered whenever the next instruction pointer reaches their location.

In order to set a location breakpoint with Visual C++ 2013, load the [sample
solution](http://bit.ly/1jOmGN9) and set the project named _Breakpoints_ as the
startup project.

![Setting up Breakpoints as the startup project](images/set-breakpoints-as-startup-project.jpg)

Then, unfold the content of the _Breakpoints_ project and double-click on the
_main.cpp_ source file. It should open _main.cpp_'s source code into the text
editor.

![Opening up Sandbox' main.cpp source file in the source code editor](images/open-main-cpp-in-breakpoints-project.jpg)

Now, add a breakpoint on the first line of code in the _main_ function by
right-clicking on it and then clicking on _Breakpoint_ -> _Insert Breakpoint_.
You can also do it by positionning your cursor on the line and pressing F9:

![Adding a new breakpoint](images/add-breakpoint-in-breakpoints-project.jpg)

Finally, build and run the program by pressing F5: the program should start
and pause when hitting the breakpoint that was just added:

![The newly added breakpoint is hit](images/breakpoint-hit-in-breakpoints-project.jpg)

As expected, the location breakpoint is triggered when the next instruction
pointer, represented by the little yellow arrow at the left of the source code
text, is at the same location. When the breakpoint is hit, the whole program
is paused. At that point, only the debugger can continue its execution from
where it paused. During a debugging session, the user is responsible for
deciding when it's time for the debugger to unpause the debuggee by pressing
F5 or clicking on the _Continue_ toolbar button.

Before examining more advanced breakpoints that will allow you to overcome
some of the limitations of basic breakpoints, the next section will explain in
details how location breakpoints are implemented.

## How basic breakpoints work {#how-location-breakpoints-work}

Location breakpoints are implemented with a specific CPU instruction: _INT 3_
(for INTerrupt number 3). It is also called the _breakpoint exception
interruption_. When the debuggee executes this instruction, the CPU calls a
specific handler previously setup by the operating system. This handler:

1. Saves the state of the debuggee and pauses it. 
2. If a debugger is attached to the debuggee, the system notifies the debugger 
process that its debuggee triggered a breakpoint by generating a _debug event_.
3. If there's no debugger watching the debuggee's process, the system generates
a breakpoint exception. If the debuggee doesn't handle the breakpoint exception,
it will abort its execution.

Programmers can trigger the breakpoint exception interruption directly in their
code to add breakpoints programmatically. To try it for yourself, open the
_Breakpoints_ project and set it as the startup project. Then, open up the
_main.cpp_ file in the text editor. Make sure that no location breakpoint is
set (no red disk is visible on the left side of the source code in the code
editor), and start debugging the program by pressing F5.

Although no breakpoint has been set in Visual C++'s IDE, the debugger will
break on the call to _\_\_debugbreak_.

![The debugger breaks on the _\_\_debugbreak_ instruction although no breakpoint has been set.](images/hardcoded-breakpoint-triggered.png)

Now, toggle the disassembly window by pressing Alt + 8. The yellow arrow
points to the code generated by the compilation of _\_\_debugbreak_.
Unsurprisingly, the disassembler shows that the compiler generated an _INT 3_
instruction:

![_\_\_debugbreak_ has been compiled to an _INT 3_ instruction.](images/hardcoded-breakpoint-disassembly.png)

[There are several ways to set breakpoints programmatically](#setting-breakpoints-programmatically).
It can sometimes be the right tool for the job. However, having to change the source code of the
debuggee every time a new breakpoint is needed is counter productive, as it requires the
debugging session to be restarted from scratch[^unless-edit-and-continue].

[^unless-edit-and-continue]: The "Edit & Continue" feature can be used to avoid restarting the debugging session, but it's not always an option. For instance, it doesn't work for optimized builds.

Luckily, there's another, more efficient way for a debugger to implement
location breakpoints. When the debugger launches the program to debug, it is
granted permissions to write to the memory area where the debuggee's code is
located. Then, it can change the debuggee's executable code so that it
executes _INT 3_ instructions at locations where the user set breakpoints.

It is actually possible to do this manually. We're going to use the debugger
to patch the debuggee's executable code and insert an _INT 3_ instruction
where we want it to break. With the same _Breakpoints_ project opened and set
as startup project, set a breakpoint on the first line of code in the _main_
function:

![Setting a breakpoint on _main_'s first line of code.](images/breakpoint-at-main-first-instruction-in-breakpoints-project.png)

Start debugging by pressing F5, the breakpoint will be hit. Show the
disassembly window by pressing Alt + 8. Toggle the memory window by pressing
ALt + 6 and copy the address of the instruction after the next instruction in
the assembly window to the address bar in the memory window. Finally, press
enter in the memory window's input field to validate your input:

![Examining the debuggee's executable code in the memory window.](images/breakpoint-assembly-and-memory-windows.png)

If instructions' addresses or code bytes do not show in the disassembly
window, make sure that the "Show Code Bytes" and "Show Address" options are
checked when right clicking in it.

We're going to do what the debugger does when setting a location breakpoint:
change the first byte of an instruction to be _0xCC_, the hexadecimal
representation of _INT 3_'s opcode. We'll change the first byte of the
instruction after the instruction pointed to by the yellow arrow, so that we
can actually verify that our change triggers a breakpoint by continuing the
debuggee's execution and checking that a breakpoint is hit.

Click in the memory window on the first byte at the top left, a grey cursor
should appear. Press the 'C' key twice on your keyboard to write INT 3's
opcode into the memory. Visual C++'s disassembly window should have updated
the assembly code with an _INT 3_ instruction to reflect your change:

![The disassembly and memory window after patching the code to add an INT 3 instruction.](images/breakpoint-assembly-and-memory-windows-after-patching-int3.png)

Now press F5, your newly added breakpoint should trigger:

![](images/patched-in-breakpoint-triggered.png)

Congratulations, you just patched some executable code live and added a
breakpoint manually!

The _INT 3_ instruction has actually been designed to be inserted by debuggers
into executable code. Its binary transcription is only one byte long, and can
thus be used to replace any other instruction, without corrupting the rest of
the code, like overwriting their operand or subsequent instructions.

But wait, why don't we see _INT 3_ instructions in the disassembly window when
we set a location breakpoint in the source code?

### Checking that Visual C++'s debugger actually uses INT 3 instructions to implement location breakpoints

Let's use the same _Breakpoints_ project that we used previously to verify
that software breakpoints are used by the debugger to implement location
breakpoints. Open the project in Visual C++ and set a breakpoint where _foo_
is assigned the value 0, at the beginning of the _main_ function:

![Setting a location breakpoint where _foo_ is assigned the value 0.](images/add-location-breakpoint-foo-assign.png)

Compile the project and start the debugger by pressing F5. The breakpoint
should be triggered.

![The location breakpoint is triggered.](images/location-breakpoint-foo-assign-hit.png)

Now, open up the disassembly window by pressing Alt + 8 to check that the
debugger actually patched the executable code where we set the location
breakpoint. Make sure that the "Show Code Bytes" and "Show Address" options
are checked when right clicking in the disassembly window.

![Make sure that addresses and code bytes are displayed in the disassembly window.](images/disassembly-right-click.png)

Surprisingly, the disassembly window doesn't show an _INT 3_ instruction, but
a _MOV_ instruction, which implements the assignation of the value 0 to the
_foo_ variable:

![The disassembly window doesn't show any INT 3 instruction where the location breakpoint was set.](images/location-breakpoint-disassembly.png)

Would Visual C++'s debugger hide some information from us? Let's verify this with the
_Memory_ window. Click on _DEBUG_ -> _Windows_ -> _Memory_ -> _Memory 1_ or
press Alt + 6. Copy the address where the location breakpoint is set and paste
it in the memory window's input field.

![Examining a location breakpoint's code with the memory window.](images/examine-location-breakpoint-code-in-memory-window.png)

At the top left corner of the memory window, the first byte stored at the
location breakpoint's adress is shown: _C7_. However, _C7_ is the hexadecimal
representation for a _MOV_ instruction's opcode, not an _INT 3_ instruction
which opcode is represented by _CC_ in hexadecimal notation.

Are we missing something or is Visual C++'s debugger lying to us again?
Let's find out by writing a simple program. This program takes a memory
address as input, reads one byte at this address and output its value. If a
location breakpoint is set at the address given as input, it should output the
value corresponding to _INT 3_'s opcode, _CC_.

Open up the _MemReader_ project and set it as your startup project. Open its
_main.cpp_ file in the text editor and set a location breakpoint before the
_while (true)_ loop:

![Setting a location breakpoint in the _MemReader_ project.](images/set-location-breakpoint-memreader-project.png)

Start debugging by pressing F5 and wait for the breakpoint to be hit. Bring up
the disassembly window by pressing Alt + 8 and copy the address where the
location breakpoint is set somewhere (for instance, in a notepad window).
Continue the execution by pressing F5 again, a prompt asking you to enter an
address should appear:

![_MemReader_ prompts for the memory address where the location breakpoint was set.](images/memreader-prompt.png)

Type in the address you copied previously and make sure it is prefixed with
_0x_, indicating that it's using an hexadecimal representation. Press enter,
the following message should appear:

    Data at address 0xf7a899: 0xcc
    Data at address 0xf7a899 IS a breakpoint opcode!

At last, we found the _INT 3_ instruction's binary code where a location
breakpoint has been set. In order to double check that _MemReader_ is not also
lying to us, let's disable the location breakpoint and see if it still detects
_INT 3_'s opcode. Display the _Breakpoints_ window by pressing Alt + F9 and
uncheck the checkbox on the line representing the location breakpoint. The
disk filled with red should become an empty red circle.

![Disabling the location breakpoint.](images/disable-location-breakpoint-memreader.png)

Now, enter the same address as before at _MemReader_'s prompt, then press
enter. The following message should be written:

    Data at address 0xf7a899: 0xf7a8990x68
    Data at address 0xf7a899 is NOT a breakpoint opcode!

Excellent, we just proved that Visual C++'s debugger hides how the debugger
patches the debuggee's executable code with _INT 3_ instructions.

The _INT 3_ instruction is called a _software breakpoint_ because it doesn't
rely on specific hardware. Programmers or debuggers just need to insert this
instruction into the debuggee's executable code where they want it to break.
There's no limit to the number of software breakpoints that can be set. This
is especially handy for location breakpoints because it is often necessary to
break at many different key places in the code to investigate issues. If there
was a limitation on the number of location breakpoints that could be set, it
would make debugging much more tedious.

On x86 and x86-64 architectures, there is another way to implement
breakpoints: _hardware breakpoints_. They are fundamentally different than
software breakpoints and have different use cases. Their usage and
implementation details are covered in [a later section of this chapter
entitled _Data breakpoints_ ](#data-breakpoints).

### Other uses of the INT 3 instruction

Because the INT 3 instruction is compiled to one byte of binary code, it's
also a very flexible tool to break into the debugger as soon as the program
executes code that should not be executed. 

#### Default value for uninitialized variables in unoptimized builds

When the _/RTC1_ (for "RunTime Checks") code generation option is enabled, the
Visual C++ compiler fills variables with the value _0xCC_.

To enable runtime checks, go the "Breakpoints" project properties by pressing
Alt + F7, then select "Configuration Properties" -> "C/C++" -> "Code
generation". Finally, set "Basic Runtime Checks" to "Both":

![Enabling runtime checks in the project properties dialog](images/basic-runtime-checks-settings.png)

Now set a breakpoint on the line of code where foo is assigned the value 0, at
the start of _main_'s implementation. Start debugging by pressing F5 and add
the variable foo to the watch window by using the ",x" format specifier.

![Unitialized variables are set to 0xCC when runtime checks are enabled.](images/basic-runtime-checks-unitialized-variable@300.png)

This default initialization is handy to detect variables that have not been
initialized when first used. With its specific pattern, it stands out from any
random value in the watch window. It's also used by the compiler to make sure
that buffer overflows or underflows did not occur during a function calls:
when the function exits, the compiler generates code that checks if data in
memory right before and after local variables still contains _0xCC_ bytes.

But why fill memory with _0xCC_? The compiler could choose to fill it with
NOPs intructions (0x90). 0xCC being the binary code for a breakpoint
exception, it allows the debuggee to trigger a breakpoint when uninitialized
data is used as executable code.

As mentioned before, the fact that the breakpoint exception instruction is
only one byte long makes it very flexible: variables of any size can be filled
with as many _INT 3_ instructions as necessary.

#### Fill instruction for padding areas of executable code

Another use of the _INT 3_ instruction is to pad the program's executable
code segment with instructions that trigger an exception that can be caught by a debugger. 

If the debugger is still paused where the breakpoint triggered, display the
disassembly window by pressing Alt + 8. Scroll up or down in the disassembly
window and you should see whole memory areas filled with _INT 3_ instructions.

![INT 3 instructions are also used to pad executable code.](images/int3-padding@300.png)

The compiler and linker usually generate executable code so that function
entry points are located on 16 or 32 bytes boundaries for performance
purposes. Any space that remains between actual executable code is padded.
Note that sometimes, other one byte instructions such as _NOP_ (0x90) can be
used for padding.

## Why more advanced breakpoints are needed

Location breakpoints are very useful to solve basic debugging challenges.
They can be added anywhere in the program's source code, and can
be removed, disabled or re-enabled at will. They are a very flexible way to
control the debuggee's execution flow.

However, more difficult debugging endeavors can be almost impossible to
overcome by using this simple tool. For instance, simple location breakpoints
_always_ break. While this is desirable most of the time, what if there's a
bug in a loop that happens only after one million iterations? Pausing the
debuggee one million times and clicking on "Continue" as many times will get
old soon.

Let's consider for instance some code with the following pattern:

{lang=c++}
~~~ 
int total = 0;
for (unsigned int i = 0; i < 1000; ++i)
{
  total += i;
}
~~~

When debugging such a loop, you may want to examine what happens at the
_891th_ iteration. With basic breakpoints, you will set a breakpoint on a
source code line within the loop. Then, because the debugger stops anytime the
next instruction pointer matches the location breakpoint, you will need to
unpause the debuggee _890_ times before you reach the state you want to
investigate. This would be very time consuming.

This is the kind of debugging problems that advanced breakpoints solve. They
build on basic breakpoints and provide additional features that make them even
more powerful.
 
The next sections presents four different types of advanced breakpoints in the following order:

* _Conditional breakpoints_ triggered when a condition specified by the user is satisfied.
* _Trace breakpoints_, also called _tracepoints_, that log some debug output when they are hit.
* _Data breakpoints_, sometimes called _memory breakpoints_, triggered when a specific area of the system's memory is used.
* _Inline breakpoints_ that act as location breakpoints, but are set by writing code using the debugger's API.

We'll also show how to combine several different types of advanced breakpoints
to obtain even more powerful tools.

## Conditional breakpoints

Conditional breakpoints combine location breakpoints with, as their name
suggests, the ability to set a custom _condition_. They trigger when the next
instruction pointer matches the location of the breakpoint _and_ a user-
specified condition is met. Thus, to setup a conditional breakpoint, it is
necessary to create a location breakpoint beforehand.

In the [sample solution](http://bit.ly/1jOmGN9), open the project named
_Breakpoints_. Set is as the startup project by right-clicking on the project's
name and then on _Set as Startup Project_. Double click on the _main.cpp_
source file to open it up in the text editor. Set a location breakpoint in the
only statement within the _for_ loop located at the top of the _main_
function:

![Adding a new basic breakpoint before setting breakpoints conditions](images/set-basic-breakpoint-in-breakpoints-project.png)

When your basic breakpoint is set at the location where you want it to
trigger, you can setup conditions by right clicking on the red disk that
represents the breakpoint on the left of the text editor:

![Conditions can be set on a basic breakpoint by right-clicking on it](images/right-click-on-basic-breakpoint.png)

You can also display the list of breakpoints in the breakpoints window
available through the _DEBUG_ -> _Windows_ -> _Breapoints_ menu, and then
right click on the corresponding breakpoint. However, I recommend using the
former method, since it's easier to see the breakpoints in the source code's
context.

In the previous screenshot, three of the contextual menu entries touch on
conditional breakpoints. These are _Condition_, _Hit Count_ and _Filter_. They
all allow programmers to specify conditions that have to be fullfilled to hit
the breakpoint.

![Conditions can be set on basic breakpoints by right-clicking on it](images/conditional-contextual-menu-entries-on-basic-breakpoint.png)

Let's start with the _Condition_ contextual menu entry.

### The condition modifier

Click on the _Condition_ menu entry. You will be presented with the following
dialog box:

![A dialog box to set breakpoint conditions](images/breakpoint-condition-dialog-box.png)

As you can see from the previous screenshot, this dialog box contains one text
field where you can enter an expression that will be evaluated by the debugger
each time the next instruction pointer reaches the breakpoint's location.

If the "Is true" option is checked, the condition will need to evaluate to
_true_ for the breakpoint to match the condition. If the "Has changed" option
is checked, the expression will need to have changed from the previous
breakpoint hit to match the condition.

The format of the expression is limited, but still offers a lot of options.
Here are the rules you need to follow when writing the condition expression:

* Only C-style comparison operators are supported. These are _==_, _!=_, _<_, etc. Any comparison operator that can be used in your C/C++ code is supported.
* Methods or function calls are not supported. [Debugger intrinsics](#debugger-intrinsics) can help you mitigate this limitation. 
* Macros are not expanded, which means that you can't write _MY_MACRO_ within this text field and expect the evaluator to expand it. Instead, you'll need to use the actual value.

Besides these limitations, some useful tools are available when writing condition expressions:

* A complete set of debugger intrinsics functions, including a comprehensive list of string comparison functions, are available to use in the condition expression. To see the full list, head over to the [debugger intrinsics cheat sheet](#debugger-intrinsics).
* Specific debugger expressions starting with "$" or "@" named _pseudo registers_ that give you access to interesting values when debugging. For the full list of pseudo registers, please refer to the [pseudo registers cheat sheet](#pseudo-registers).

Let's try to use a simple conditional breakpoint. Enter the expression
_loopFoo % 2 == 0_ in the condition text field:

![Using simple comparison operators in breakpoints conditions](images/breakpoint-condition-modulo.png)

Notice how the breakpoint's icon's appearance changes. A white cross is now
visible in the middle of the red disk:

![A white cross appears in the middle of a breakpoint's icon if a condition is set](images/conditional-breakpoint-icon-with-cross.png)

A white cross means that one or more of the three conditional modifiers
(Condition, When hit or Filter) apply to a breakpoint.

Start debugging the program by pressing _F5_. The conditional breakpoint you
just set should hit five times, each time the variable _loopFoo_ is even.
Congratulations, you've just used your first advanced breakpoint!

Conditional breakpoints can be used anywhere, not just within loops. In the
same _Breakpoints_ project, add a breakpoint in _SomeClass_'s method named
_increaseSomeValue_:

![Setting a breakpoint in _SomeClass_' _increaseSomeValue_ method](images/breakpoint-someclass-increase-some-value.png)

Then, bring up the breakpoint modifiers contextual menu by right-clicking on
the newly added breakpoint and click on "Condition...". Then, within the
condition dialog's text input field, write the condition _m\_someValue == 1_:

![Conditional breakpoints can be set anywhere, not just within loops](images/breakpoint-someclass-increase-some-value-condition.png)

Finally, hit _F5_ to start debugging the program. The breakpoint you just set
should be hit. Hover with your mouse pointer on _m_someValue_'s declaration:
its value is 1, which corresponds to the breakpoint condition modifier we just
set. There's no constraint on where you can use breakpoints modifiers, including
condition modifiers.

#### Breaking only when some state changed

We haven't covered the "Has Changed" option of the "Condition" modifier dialog yet.

In the _Breakpoints_ project, add a new location breakpoint in the loop where
_foo_ is modified, and another one right after the end of the
loop, where _foo_ is assigned the value _42_:

![Setting up two conditional breakpoints to monitor changes made to _foo_.](images/condition-has-changed-breakpoint-size-format-specifier@300.png)

Set the same "Condition" modifier for both of them:

![Using the size format specifier and the "Has Changed" option to monitor changes made to a data buffer.](images/condition-has-changed-breakpoint-size-format-specifier-dialog@300.png)

If you look at the content of the variable _loopFoo_, you'll
see that the breakpoint triggered the second time that the CPU executed the
instruction at the address where it's located. Why didn't it trigger the first
time that the program wrote to _foo_?

The key concept here is that, with conditional breakpoints, we're still using
_location_ breakpoints. The way a conditional breakpoint using the "Has
Changed" option works is that, when the code at the breakpoint's location is
executed, the condition is evaluated. If this evaluation yelds a different
value than the previous one, the breakpoint triggers.

When the code reaches the breakpoint's location for the first time, there's no
previous evaluation against which to test the current evaluation, so the
breakpoint will not trigger.

For the same reason, if you disable the first conditional breakpoint we just
set and press F5, execution will continue without triggering the second
conditional breakpoint. Indeed, there's no chance that the CPU executes code
at this location more than once, so the conditional never has any chance to
trigger.

#### Watching large chunks of data

So far, we have shown how to trigger breakpoints when the next instruction
pointer reaches a given location, when some expression evaluates to true or
when the value of an expression changes.

However, these tools do not cover a typical use case when debugging programs:
watching _a large chunk of data_ and being notified when _any of its
elements_ changes.

It turns out that the "Has Changed" check box of the "Condition" modifier can
help us do that. The trick is to use it in conjunction with a _size format
specifier_.

In the _Breakpoints_ project, add a new location breakpoint in the loop where
_buffer_ is modified:

![Setting up a conditional breakpoint to monitor changes made to a data buffer.](images/condition-has-changed-breakpoint-size-format-specifier@300.png)

Set the "Condition" modifier:

![Using the size format specifier and the "Has Changed" option to monitor changes made to a data buffer.](images/condition-has-changed-breakpoint-size-format-specifier-dialog@300.png)

As you can see from the previous screenshot, the _,1024_ format specifier
means that the debugger will evaluate the 1024 items starting at _buffer_ and,
if any of them changes, will trigger the breakpoint.

Now start debugging the program by pressing F5. The conditional breakpoint
will be hit during the second iteration of the loop.

In some way, this section's title is a bit misleading. Conditional breakpoints
used in conjunction with size format specifiers do not allow to watch chunks
of data in memory at all times.

They can trigger only when the CPU executes the instruction at the
breakpoint's location, and they need the CPU to reach it at least twice.
However [data breakpoints](#data- breakpoints), the only way to watch for
memory writes at all times, have some serious limitations in terms of size and
number that make this solution the best tool available right now with Visual
C++'s debugger to monitor large chunks of data.

#### Exercice

In the _Breakpoints_ project, set a conditional breakpoint that breaks
everytime the _currentString_ variable holds the string _"foo"_. Hint: use
[debugger intrinsics](#debugger-intrinsics).

### The hit count modifier

Another way to implement a conditional breakpoint is to use the _Hit Count_
contextual menu entry of advanced breakpoints:

![Setting a hit count to create a conditional breakpoint](images/breakpoint-hit-count.png)

Delete the conditional breakpoint you created previously, and create another
breakpoint at the same location, in the for loop. Then click on the _Hit
Count_ contextual menu entry. You will be presented with the following dialog:

![Hit count breakpoint dialog](images/breakpoint-hit-count-dialog.png)

By default, this dialog is set to "Break always", which makes the breakpoint
act as a basic, location breakpoint. This setting is nonetheless already very
helpful, since the "Current hit count" label displays the number of times that
the breakpoint has been hit.

Click on the list box, and you'll see, in addition to the default "break
always" choice, three different hit count options:

![Different settings for hit count breakpoints](images/breakpoint-hit-count-dialog-expanded.png)

As you can see from this screenshot, a hit count breakpoint breaks the
debuggee when the next instruction pointer matches the breakpoint location,
_and_ it has been hit the number of times specified in the dialog box. A hit
count breakpoint is equivalent to a breakpoint with a condition modifier where
the condition would be true depending on the number of times the breakpoint
has been hit.

Here's a table that matches condition expressions with each hit
count setting available:

|Hit count setting     | Condition expression              |
|----------------------|-----------------------------------|
|break when the hit    | someVariable == desiredHitCount   |
|count is equal to     |                                   | 
|----------------------|-----------------------------------|
|break when the hit    |  someVariable % someMultiple == 0 |
|count is a multiple   |                                   |
|of                    |                                   |
|----------------------|-----------------------------------|
|break when the hit    | someVariable >= someHitCount      |
|count is greater than |                                   |
|or equal to           |                                   |

One might wonder why use the hit count modifier if the condition modifier can
achieve exactly the same thing, while allowing more flexibility. The reason
for using the hit count modifier over the condition modifier is there's no
need for a variable in your source code to hold the current hit count. This is
very handy when, for instance, during a debugging session, you want to break
depending on the hit count, but you can't change the source code without
stopping the program.[^edit-and-continue]

[^edit-and-continue]: It is sometimes possible to change your code during a debugging session without stopping the program by using the Edit & Continue feature. However, Edit & Continue has some serious limitations, and won't work in all cases.

#### The filter modifier

The filter modifier is the latest modifier that helps to create conditional
breakpoints. It allows programmers to trigger a breakpoint depending on the
following conditions:

* The current Windows machine name. 
* The current process id. Note that this is the debuggee's process id, not the debugger's process id. 
* The current thread id. As for the current process id, this is the debuggee's thread id, not the debugger thread id.
* The current thread name. As for the current thread id, this is the debuggee's thread name, not the debugger thread name. The thread name can be set programmatically. For more information about other advanced debugging tools when debugging multi-threaded programs, see the [Multi-threading advanced debug tools section](#multi-threading-advanced-debug-tools).

Individual conditions can be combined using logical operators _&_ (logical
and), _||_ (logical or) and _!_ (logical not).

### Combining modifiers

While individual modifiers are very helpful on their own, Visual C++'s
debugger allows you to mix and match them for greater flexibility. For
instance, you can set a condition, hit count and filter modifier at the same
time on any breakpoint. The modifiers will be combined using a logical _and_
operator, meaning that all modifiers will need to be satisfied in order for
the breakpoint to be triggered.

## Trace breakpoints

Trace breakpoints combine location breakpoints and the ability to output log
messages in Visual C++'s output window.

Location breakpoints pause the the debuggee's execution and allow programmers
to examine its current state. They give them all the time needed to to
inspect current variables' value, walk the callstack and browse the
debugee's memory. This is very powerful and, most of the time, it's sufficient
to find the solution to even complex bugs. However, once the debugee's
execution continues, all this information is lost. Without a way to keep a log
of the debuggee's state, some bugs can be very difficult to investigate.

This is where trace breakpoints can help. They allow you to output some debug
logs in the output window whenever a breakpoint is hit.

Let's use our _Breakpoints_ project to add a trace breakpoint that will output
some information when we call _SomeClass::increaseSomeValue_. As for all
breakpoint modifiers, you'll first need to create a "normal" or "location"
breakpoint in order to add a trace breakpoint. Then right-click the newly
created breakpoint and click on "When Hit...":

![Creating a trace breakpoint](images/trace-breakpoint-creation.png)

At that point, the following dialog will show:

![Trace breakpoint creation dialog](images/trace-breakpoint-creation-dialog.png)

In this dialog, you will need to check the _Print a message_ checkbox in order
to be able to specify what output log message to print when the breakpoint is
hit. When doing so, the online help will show you what syntax you can use to
display dynamic values, such as variables' values, the current callstack, the
caller, etc. Any expression that can be used in the [watch window](#watch-
window) can be used in this dialog's input field, including [pseudo-registers
](#pseudo-registers) and [format specifiers](#format- specifiers). For
instance, if you want to print the latest error code set with _SetLastError_,
simply enter _Latest error: {$err,hr}_ in the text field.

![Logging the latest error set by SetLastError using a trace point](images/trace-breakpoint-creation-dialog-output-message.png)

When a trace breakpoint is hit, its output is sent to the _Output_ window. The
output window can be displayed by clicking on the _DEBUG_ -> _Windows_ ->
_Output_ menu entry. Start debugging the project, and you should see the
following messages in the output window:

![Output messages logged using trace breakpoints are visible in the output window](images/trace-breakpoint-output-messages.png)

Note that it is possible to programmatically log messages in the output
window, without using trace breakpoints. In order to do this, you will need to
use the _OutputDebugString_ function covered in the [section about the
debugger's API](#debugger-api).

By default, trace breakpoints do not pause the debuggee's execution when hit.
In this case, they appear as a red diamond instead of a red circle. You can
make them pause the debuggee's by unchecking the "Continue execution"
checkbox:

![Setting a trace breakpoint to pause debuggee's execution](images/trace-breakpoint-creation-dialog-pause-execution.png)

When trace breakpoints pause the debuggee's execution, their appearance change
for a red circle, like for normal location breakpoints.

### A word about trace breakpoints' performance

Trace breakpoints are very usefull, and it can be tempting to use them instead
of writing extra logging code that has to be conditionnally deactivated for
production builds. However, trace breakpoints have a very significant impact
on performance. If they're hit very frequently (several times per second),
they will dramatically slow down your process, to the point where the
debuggee's becomes barely usable. The debugger and the whole system will also
take a big performance hit. Why is that?

Trace breakpoints are implemented the same way as any other "blocking"
breakpoint, except they don't wait for a user interaction to continue the
debuggee's execution. Each time the code at the trace breakpoint's location is
executed, the CPU emits the same debug event as when a normal location
breakpoint is hit. The operating system pauses the debuggee and send this
debug event to the debugger. This event is caught by the debugger, which
patches the debuggee's executable code[^debuggee-code- patching]. Then,
instead of waiting for the user to continue the debuggee's execution, the
debugger automatically performs a system call that continues the debuggee's
execution.

Hitting trace breakpoints very frequently adds a lot of context switching
between the debugger and the debuggee with a negative impact on their
performance.

[^debuggee-code-patching]: If you'd like to know more about why the debugger needs to patch the debuggee's executable code when a breakpoint is hit, go to the section entitled [How debuggers work](#how-debuggers-work).

### Combining trace breakpoints with conditional breakpoints

In the same way you can combine other modifiers, you can combine the _When
Hit_ modifier with all other modifiers to output some debug trace when your
conditional breakpoints are hit.

However, there's one drawback to this flexibility: setting many modifiers on a
breakpoint that is triggered very frequently (every second or more) can have a
big hit on the debuggee's performance. Using the minimum amount of modifiers
to solve your debugging challenges is a best practice that will help you keep
your debuggee's performance at a reasonnable level. It will make the debugging
experience all the more enjoyable.

## Data breakpoints {#data-breakpoints}

Data breakpoints, sometimes named memory breakpoints, are used to pause the
debuggee when a memory I/O operation is performed on a given range of its
address space. For instance, a data breakpoint can be set to pause the program
if four bytes of memory starting at address 0x07032345[^32-bits-address] are
written.

[^32-bits-address]: We're using a 32 bits address for convenience here, the address size depends on your target platform.

Data breakpoints are fundamentally different than traditional location
breakpoints. Instead of being hit when the next instruction to be executed
matches a given address, they can be triggered by any instruction of the
debuggee's code.

Usage of data breakpoints is appropriate when it's easier to reason about the
erroneous data rather than the code that causes it. Sometimes, the execution
paths that the code can take are well-known to us and identified, but its
output is wrong. In these cases, normal location breakpoints are handy because
they allow us to set check points at known code locations where we can check
inputs and outputs to finally pinpoint the source of the bug.

In other situations, code can take many different execution paths that are
still unknown to us, either because the code is very complex, or because  it's
not familiar to us. However, the erroneous data can be located  very easily in
memory. Data breakpoints allow programmers to indicate the erroneous data's
address and find out which code path generates it.

Data breakpoints are not attached to code, and thus are not created in the
code editor. Moreover, since they operate on the debuggee's data, 
the program to debug has to be started and its data loaded before they can
be created.

To illustrate this, stop any ongoing debugging session in Visual C++. Make
sure the _Breakpoints_ project is loaded and hover on the _DEBUG_ -> _New
Breakpoint_ menu entry. The _New Data Breakpoint_ menu entry is disabled.

![The program to debug needs to be started before data breakpoints can be set](images/data-breakpoint-disabled-when-program-not-started.png)

Now, add a location breakpoint on the first line of the _main_'s function
implementation.

![Adding a breakpoint at the start of _main_'s function will allow us to set a
data breakpoint when the debuggee's data is loaded into its address
space](images/set-location-breakpoint-at-top-of-main.png)

Start debugging the program: the breakpoint you just set will
be hit. At that point, creating a data breakpoint is possible because the
debuggee's data is loaded in its address space.

![Creating a data breakpoint now that the debuggee's data is loaded](images/data-breakpoint-creation.png)

Another way to create a data breakpoint is to use the Breakpoints window
available via the _DEBUG_ -> _Windows_ -> _Breakpoints_ menu entry. Click on
the _New_ toolbar button and then on _New Data Breakpoint..._.

![Creating a data breakpoint from within the Breakpoints window](images/data-breakpoint-creation-alternate.png)

When creating a new data breakpoint, the following dialog appears:

![Data breakpoint creation dialog](images/data-breakpoint-creation-dialog.png)

This dialog contains two input text fields:

* The address of the first byte of data that will trigger the data breakpoint if a memory write operation is made. 
* The size in bytes of the memory area for which the data breakpoint will be valid.

By default, the size is set to four bytes. It is well suited for data types
for which _sizeof_ returns 4. However, you should change it if the data you're
monitoring has a different size. For instance, to trigger a breakpoint anytime
an ASCII character is changed, the size should be set to one byte. If you set
it to four bytes, it will trigger for characters that are adjacent in memory.

Let's set our new data breakpoint to trigger when the data represented by the
variable named _foo_ changes. To do that, enter the expression _&foo_ in the
_Address:_ input text field of the data breakpoint creation dialog. Since
_foo_ is of type _int_ and _sizeof(int)_ is four bytes on x86, the default
size of four bytes is fine.

![Setting the address for a new data breakpoint](images/data-breakpoint-creation-dialog-set-address.png)

The language input field is used as a label to later retrieve and sort your
breakpoints by programming language name. It doesn't have any impact on how
your data breakpoint behaves.

Click OK, and the _Breakpoints_ window should now list your new data breakpoint.

![The newly created data breakpoint has been added to the list of breakpoints
in the _Breakpoints_ window](images/data-breakpoint-added.png)

Note how its name differ from the location breakpoint we set earlier. The
location breakpoint's name mentions a line number, whereas the data breakpoint
mentions a memory address, and a data size. Now that the data breakpoint has
been set, continue the debuggee's execution by pressing _F5_.

Because the first instruction of the _main_ function initializes the variable
_foo_ with the value _0_, the data breakpoint triggers. Visual C++'s debugger
displays a modal dialog and the next instruction pointer points towards the
next instruction to be executed when the debuggee's execution continues.

![The data breakpoint is triggered for the first time, following the write of
the value 0 to the memory area represented by the variable _foo_](images/data-
breakpoint-first-hit.png)

Now let's continue the debuggee's execution by pressing _F5_ again. What
happens is interesting: the breakpoint paused the program outside of _main_'s
implementation, where there's no breakpoint setup. 

![The data breakpoint is hit a second time outside of _main_'s
implementation](images/data-breakpoint-second-hit.png)

When we look at the callstack, the reason why the breakpoint triggered is
clear: _ChangeData_ wrote to the memory area represented by the variable
_foo_.

![The callstack at the time of the data breakpoint's second hit](images/data-breakpoint-second-hit-callstack.png)

If you continue pressing _F5_ to resume the debuggee's execution, the same
data breakpoint will be triggered every time some data is written to the
memory identified by _foo_, as expected.

### Choosing your data breakpoints' size carefully

Data breakpoints' size is four bytes by default. It works well for four-bytes
integer data like the data represented by the variable _foo_ in our
_Breakpoints_ project. However, choosing the right size for your data
breakpoints is key.

Let's re-use the data breakpoint that was created earlier and change its size
to one byte. In order to do so, stop the current debugging session and restart
it by pressing _F5_. The debugger should pause when hitting the location
breakpoint set at the beginning of _main_'s implementation. Go to the
_Breakpoints_ window by clicking on _DEBUG_ -> _Windows_ -> _Breakpoints_. The
data breakpoint created earlier is still present, but deactivated:

![Data breakpoints are deactivated upon restarting a debugging session](images/data-breakpoint-deactivated-after-restart.png)

Data breakpoints need to be re-enabled every time a debugging session starts.
Even worse, unless the _Randomized Base Address_ linker properties' option is
disabled (which is the case in our _Breakpoints_ project, but not by default),
any address that is referred to by the debugger will change between debugging
sessions. To learn more about these limitations and how to overcome it, at
least partially, go to the section entitled [Persistence accross debugging
sessions](#data-breakpoints-persistence-accross-debugging-sessions). For now,
let's just re-enable it and change its size to 1. In the same _Breakpoints_
window, right click on the disabled data breakpoint and click on
_Location..._:

![To edit a data breakpoint's address, click on Location...](images/data-breakpoint-edit-location.png)

The same dialog as when creating a new data breakpoint appears. Change the
"Byte count" input text field from 4 to 1:

![Changing a data breakpoint's size](images/data-breakpoint-edit-size.png)

Click OK and start debugging the program by pressing F5. The data breakpoint
should pause the debuggee in the same situations as before, including when
_ChangeData_ executes _data = 42;_. Now stop the debugger and change this line
of code from _data = 42;_ to _data = 0xFF000000;_. Restart the debugging
process (don't forget to re-enable the data breakpoint). The data breakpoint
triggers when initializing _foo_ to 0, but it doesn't trigger when calling
_ChangeData_. 

The reason is data breakpoints trigger _only when new data is written to a
memory address_. When _data = 0xFF000000;_ is executed, _data_ refers to the
same data as the _foo_ variable in the _main_ function's scope. _foo_ has
already been initialized to 0x00000000 (the 32 bits hexadecimal representation
of 0), and thus writing 0xFF000000 to it only changes the most significant
byte. Because the data breakpoint now triggers only if one byte changes, and
the Intel architecture is little-endian, the change to the most significant
byte of _foo_ does not trigger the data breakpoint.

Change the code to _data = 0x000000FF;_ in _ChangeData_'s implementation,
restart the debugging session and re-enable the data breakpoint: it will
trigger again when _ChangeData_ is called.

### How data breakpoints work under the hood {#how-data-breakpoints-work}

We presented earlier [how location breakpoints are implemented using _software
breakpoints_](#how-location-breakpoints-work). Using the _INT 3_ instruction
is well suited to trigger a breakpoint when an instruction at a given address
in the debuggee's code is executed. However, it can't be used to trigger a
breakpoint depending on some operation performed on the debuggee's data.

With data breakpoints, the CPU needs a way to know for which address(es) a
breakpoint exception needs to be raised when some memory operation is
performed. The most convenient and efficient way to store these addresses is
to use _debug registers_ on the CPU. This is why it is said that data
breakpoints are implemented with _hardware breakpoints_: they depend on actual
hardware. Because hardware is, by definition, finite and limited, data
breakpoints are [limited both in size and number](#data-breakpoints-size-and-number-limitation).

On x86 and x86-64 architectures, there are eight debug registers named _DR0_
to _DR7_.

_DR7_ is a debug control register that determines what conditions should
trigger a breakpoint exception:

* When a memory write is performed.
* When a memory read or a memory write is performed.
* When an instruction is executed.

Depending on the bits set in _DR7_, registers _DR0_ to _DR3_ have a different
meaning. If _DR7_ is set to trigger a breakpoint exception when a memory write
or read is performed, the content of _DR0_ to _DR3_ is used to determine for
which memory address written to or read from the exception should be raised.
If _DR7_ is set to trigger when an instruction is executed, memory addresses
in _DR0_ to _DR3_ are used to determine the addresses in the executable code
that should trigger the breakpoint when they are executed. It also determines
the size of the memory area to watch when the mode is set to break on memory
reads and/or writes. The size is stored as a two bits number but only sizes of
one, two and four bytes are supported on x86. On x86-64, data breakpoints of 8
bytes are also supported.

Hardware breakpoints could be used to implement location breakpoints since
they can trigger a breakpoint exception when a given instruction is executed.
However, that would limit programmers to use no more than four of them. The
_INT 3_ instruction is much better suited to implement location breakpoints,
since it doesn't suffer from this limitation. Thus, one mode of the _DR7_
register, breaking on instruction execution, is rarely used.

Depending on the content of the DE flag in CR4, _DR4_ and _DR5_ are either
aliases to _DR6_ and _DR7_, or their use would trigger an _invalid opcode_
excetion.

Finally, _DR6_ is a debug status register that reports the reason why a data
breakpoint triggered.

To see the data breakpoints' implementation in action with Visual C++'s
debugger, set the project named "HowDataBreakpoints" work as the startup
project and open its _main.cpp_ file in the code editor. Then, set a
breakpoint on the _while_ statement.

![Using the project named "HowDataBreakpointsWork" to illustrate data breakpoints' implementation.](images/how-data-breakpoints-work.png)

Start debugging the program and when the breakpoint is triggered, add a data
breakpoint by clicking on _DEBUG_ -> _New Breakpoint_ -> _New Data
Breakpoint..._. Enter an address that is easy to remember for the newly
created data breakpoint, the size is not important (as long as it's less or
equal than 4 bytes on x86, and less or equal than 8 bytes on x64). Now press
_F5_ to continue the debuggee's execution, you should hit the breakpoint again.
Press _Alt + Tab_ to display the program's output window: you should see the
address of your data breakpoint in the output. 

Continue adding/disabling/removing data breakpoints and see how it affects the
output.

### Data breakpoints' limitations

Data breakpoints are very powerful and can help solving issues that standard
location breakpoints can't. However, because they're based on actual hardware,
they are by definition limited. This section presents these limitations and
how to work around them when possible.

#### Triggered only if data changes

One of the most counter-intuitive features of data breakpoints is that they're
triggered only when data changes, not when any write operation occurs.

#### Persistence accross debugging sessions {#data-breakpoints-persistence-accross-debugging-sessions}

Another irritating characteristic of data breakpoints is that they're always
disabled when a new debugging session starts. The reason is that most of the
time, data breakpoints are set on addresses that change every time the program
is executed. 

Indeed, you may set a data breakpoint on data that is stored in the process'
heap. Chances are that, during the next run of your program, data stored on
the heap will change. Any data breakpoint set previously is likely to point to
different or invalid data.

Another example is if you set a data breakpoint's to break when some global
data belonging to a DLL is changed. When this DLL is compiled with different
code  generation settings, chances are the address of the global data will
change, and your data breakpoints will not trigger as expected.

If that wasn't enough to convince you that adresses of objects in memory can
change between two debugging sessions, one of Window's security feature called
_ASLR_ (for _Address Space Layout Randomization_) randomizes the address space
of any process so that attackers can't easily guess the address of data when a
program runs. This means that every time a program is loaded into memory, no
memory address for any object is the same. Thus, any data breakpoint set
previously is invalid. This feature can be disabled if you want to avoid
resetting your data breakpoints' address every time a new debugging session
starts. Just go to your project's properties, click on "Configuration
Properties", "Linker", "Advanced" and  choose "No" for the "Randomized Base
Address" setting:

![Disabling Randomized Base Address for easier data breakpoints usage](images/disable-randomized-base-address.png)

As indicated in the screenshot, this configuration property can be set for
both optimized and unoptimized builds safely. However, make sure that your
product is not shipped with this setting enabled, as it would have a negative
impact on security.

The list of use cases that can invalidate data breakpoints' addresses is long,
so Visual C++'s developpers decided to disable data breakpoints by default
when a debugging session starts instead of anwsering countless support
requests by confused users.

#### Data breakpoints sometimes do not work as expected with optimized code

When compilers optimize code, one of their tool of choice is using the fastest
unit of hardware available to store data. This is why, in optmized builds, a
lot of data is stored in registers instead of in memory. The problem with this
approach when debugging is that the debugger cannot be notified when the
debuggee writes to a register. It can only be notified when the debuggee
writes to specific addresses in the main memory.

This issue happens only with intermediate data stored on the stack, not with
data that is stored on the heap and persists for longer than a function call.
For instance, you won't be able to set a data breakpoint on _foo_'s memory
address in a "Release" build of the "Breakpoints" project. Indeed, _foo_ has a
very short life and sits on the stack. However, allocating some data with
_malloc_ or _new_ and setting a data breakpoint on the returned address should
work reliably.

As a general rule, you should not use data breakpoints for short lived data
that is allocated on the stack. You shouldn't need it anyway, because the
location of the code that changes it should be easy to find in the function
where the data is used.  In these cases, it is most likely a sign that a
location breakpoint should be used, not a data breakpoint.

#### Number and size limitations {#data-breakpoints-size-and-number-limitation}

As mentionned in the previous section entitled [how data breakpoints work
](#how-data-breakpoints-work), data breakpoints are implemented using four
registers holding memory addresses to watch. Debug registers being pieces of
hardware, this number cannot be extended, and Visual C++'s debugger will show
an error dialog if you try to set more than four data breakpoints:

![Adding more than 4 data breakpoints results in an error.](images/data-breakpoints-limited-to-4.png)

Moreover, all other data breakpoints' settings, including the size of the
memory area for which to check write operations, are held in hardware
registers. For this reason, the size of the memory area that data breakpoints
can watch is limited to 4 bytes on the x86 platform, and 8 bytes on the x64
platform.

![Visual C++'s debugger cannot set data breakpoints with a size larger than 4 or 8 bytes depending on the platform.](images/data-breakpoint-too-large.png)

#### Only write operations trigger data breakpoints in Visual C++'s debugger

Although the Intel architecture supports data breakpoints that trigger on read
operations, Visual C++'s debugger only supports data breakpoints that trigger
on write operations. However, it is possible to set such data breakpoints
programmatically, by using the [_SetThreadContext_](http://msdn.microsoft.com/en-us/library/windows/desktop/ms680632%28v=vs.85%29.aspx) API. For more information on how to use this API, Michael Chourdakis has written [a concise tutorial on CodeProjet](http://www.codeproject.com/Articles/28071/Toggle-hardware-data-read-execute-breakpoints-prog?fid=1519331&fr=1&df=90&mpp=25&noise=3&prof=False&sort=Position&view=Normal&spc=Relaxed) with some sample code.

## Setting breakpoints programmatically {#setting-breakpoints-programmatically}

The latest type of breakpoints are breakpoints that are actually triggered by using the debugger's API.
There are three ways to use this API, and depending on the platforms, some of them are not available:

* Writing inline assembly to use the INT 3 instruction.
* Calling the _\_\_debugbreak_ intrinsic.
* Calling the _DebugBreak_ function.

### Using INT 3

This method is specific to the x86 platform. The reason for this limitation is
that using the _INT 3_ interrupt requires writing inline assembly, which is
not supported on the x86-64 platform[^inline-assembly-on-x86-64].

[^inline-assembly-on-x86-64]: Instead of using inline assembly, Microsoft suggests to use the compiler's equivalent intrinsics.

To see this type of breakpoint in action, open up the _Breakpoints_ project and 
uncomment the following line of code:

{title="Using inline assembly to trigger a breakpoint",lang=c++}
~~~ 
__asm int 3;
~~~

Start debugging the program and continue execution until the debugger breaks:

![The debugger breaks on a breakpoint set using inline assembly](images/inline-asm-breakpoint.png)

Now press Alt + 8 to go to the disassembly window to see what code was
generated by the _\_\_asm int 3;_ instruction:

![The disassembly window shows us what binary code was generated for the inline breakpoint.](images/inline-asm-breakpoint-disassembly.png)

Without too much surprise, the compiler generated the _0xCC_ opcode, the same
one used by Visual C++'s debugger to set new location breakpoints during
debugging sessions.

### Using the debugger's _\_\_debugbreak intrinsic

The x86-64 platform does not support inline assembly. However, programmers can
use Visual C++'s debugger's _\_\_debugbreak_ intrinsic to achieve the same
thing. Open up the _Breakpoints_ project and start a debugging session by pressing _F5_. Continue execution until the debugger breaks on the call to _\_\_debugbreak_:

![The debugger breaks on the _\_\_debugbreak_ intrinsic.](images/debugbreak-intrinsic.png)

Now, press Alt + 8 to display the disassembly window:

![The _\_\_debugbreak_ intrinsic generates the same INT 3 instruction used by the debugger to set location breakpoints.](images/debugbreak-intrinsic-disassembly.png)

Once again, when compiled, the _\_\_debugbreak_ intrinsics generates a _INT 3_
instruction, the same used by the debugger to implement location breakpoints.

### Using the _DebugBreak_ system function

The latest way to programmatically set a breakpoint is to use the _DebugBreak_ system function.
If the _Breakpoints_ project is still being debugged, simply continue the execution until you break on the call to _DebugBreak_:

![The debugger breaks on the call to the _DebugBreak_ system function.](images/debugbreak-function.png)

There is one difference between this method and the two previous ones: he debugger breaks _inside_ the call to _DebugBreak_, as the next call stack window's screenshot indicate.

![A screenshot of the callstack window when the debugger breaks because of call to _DebugBreak_.](images/debugbreak-function-callstack.png)

## Resources

* The [Intel Architecture Software Developer manual](http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html), Volume 3, chapter 17. Contains in-depth documentation about how Intel CPUs support breakpoints.
* Section "INT n/INTO/INT 3-Call to Interrupt Procedure" of the [Intel Architecture Software Developer manual](http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html), Volume 2, Chapter 3, page 404. 