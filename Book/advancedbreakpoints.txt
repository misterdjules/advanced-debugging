# Advanced breakpoints

Breakpoints are one of the most important tools when debugging a program
during development. They allow programmers to pause at any desired point in
their execution flow and investigate their state. Without breakpoints,
programmers would need to log information to some output device to understand
how a program behaves.

While relying on debug output logs to investigate an issue can be fine in some
situations, it is often inadequate. Large programs can take a very long time
to build and link. Using only debug output logs to debug programs requires
them to be built and linked every time a programmer wants to change the debug
output, making the process slow and frustrating. Moreover, writing debug
output code can change the debuggee's behavior such that bugs appear or
disappear.

Although it is very likely that you're already familiar with basic
breakpoints, this chapter starts by a very quick review of how to use them,
just to make sure that everyone is on the same page.

Then, the focus will be on introducing two types of breakpoints that most
people don't know about: _conditional_ and _data_ or _memory_ breakpoints.
We'll show when they're most useful and how to use them. Conditional
breakpoints are implemented on top of basic breakpoints, but data breakpoints
work quite differently. We'll present their differences and show you how to
combine these two types of breakpoints to get even more powerful tools.

At the end of this chapter, you will have acquired a new set of tools to boost
your productivity and your efficiency when debugging programs.

## Basic breakpoints

Basic breakpoints are also called _location_ breakpoints because they are
triggered whenever the next instruction pointer reaches their location.

In order to set a location breakpoint with Visual C++ 2013, load the [sample
solution](http://bit.ly/1jOmGN9) and set the project named _Breakpoints_ as the
startup project.

![Setting up Breakpoints as the startup project](images/set-breakpoints-as-startup-project.jpg)

Then, unfold the content of the _Breakpoints_ project and double-click on the
_main.cpp_ source file. It should open _main.cpp_'s source code into the text
editor.

![Opening up Sandbox' main.cpp source file in the source code editor](images/open-main-cpp-in-breakpoints-project.jpg)

Now, add a breakpoint on the first line of code in the _main_ function by
right-clicking on it and then clicking on _Breakpoint_ -> _Insert Breakpoint_.
You can also do it by positionning your cursor on the line and pressing F9:

![Adding a new breakpoint](images/add-breakpoint-in-breakpoints-project.jpg)

Finally, build and run the program by pressing F5: the program should start
and pause when hitting the breakpoint that was just added:

![The newly added breakpoint is hit](images/breakpoint-hit-in-breakpoints-project.jpg)

As expected, the location breakpoint is triggered when the next instruction
pointer, represented by the little yellow arrow at the left of the source code
text, is at the same location. When the breakpoint is hit, the whole program
is paused. At that point, only the debugger can continue its execution from
where it paused. During a debugging session, the user is responsible for
deciding when it's time for the debugger to unpause the debuggee by pressing
F5 or clicking on the _Continue_ toolbar button.

## Why more advanced breakpoints are needed

Location breakpoints are very useful to solve basic debugging challenges.
They can be added anywhere in the program's source code, and can
be removed, disabled or re-enabled at will. They are a very flexible way to
control the debuggee's execution flow.

However, more difficult debugging endeavors can be almost impossible to
overcome by using this simple tool. For instance, simple location breakpoints
_always_ break. While this is desirable most of the time, what if there's a
bug in a loop that happens only after one million iterations? Pausing the
debuggee one million times and clicking on "Continue" as many times will get
old soon.

Let's consider for instance some code with the following pattern:

{lang=c++}
~~~ 
int total = 0;
for (unsigned int i = 0; i < 1000; ++i)
{
  total += i;
}
~~~

When debugging such a loop, you may want to examine what happens at the
_891th_ iteration. With basic breakpoints, you will set a breakpoint on a
source code line within the loop. Then, because the debugger stops anytime the
next instruction pointer matches the location breakpoint, you will need to
unpause the debuggee _890_ times before you reach the state you want to
investigate. This would be very time consuming.

This is the kind of debugging problems that advanced breakpoints solve. They
build on basic breakpoints and provide additional features that make them even
more powerful.
 
The next sections presents four different types of advanced breakpoints in the following order:

* _Conditional breakpoints_ triggered when a condition specified by the user is satisfied.
* _Trace breakpoints_, also called _tracepoints_, that log some debug output when they are hit.
* _Data breakpoints_, sometimes called _memory breakpoints_, triggered when a specific area of the system's memory is used.
* _Inline breakpoints_ that act as location breakpoints, but are set by writing code using the debugger's API.

We'll also show how to combine several different types of advanced breakpoints
to obtain even more powerful tools.

## Conditional breakpoints

Conditional breakpoints combine location breakpoints with, as their name
suggests, the ability to set a custom _condition_. They trigger when the next
instruction pointer matches the location of the breakpoint _and_ a user-
specified condition is met. Thus, to setup a conditional breakpoint, it is
necessary to create a location breakpoint beforehand.

In the [sample solution](http://bit.ly/1jOmGN9), open the project named
_Breakpoints_. Set is as the startup project by right-clicking on the project's
name and then on _Set as Startup Project_. Double click on the _main.cpp_
source file to open it up in the text editor. Set a location breakpoint in the
only statement within the _for_ loop located at the top of the _main_
function:

![Adding a new basic breakpoint before setting breakpoints conditions](images/set-basic-breakpoint-in-breakpoints-project.png)

When your basic breakpoint is set at the location where you want it to
trigger, you can setup conditions by right clicking on the red disk that
represents the breakpoint on the left of the text editor:

![Conditions can be set on a basic breakpoint by right-clicking on it](images/right-click-on-basic-breakpoint.png)

You can also display the list of breakpoints in the breakpoints window
available through the _DEBUG_ -> _Windows_ -> _Breapoints_ menu, and then
right click on the corresponding breakpoint. However, I recommend using the
former method, since it's easier to see the breakpoints in the source code's
context.

In the previous screenshot, three of the contextual menu entries touch on
conditional breakpoints. These are _Condition_, _Hit Count_ and _Filter_. They
all allow programmers to specify conditions that have to be fullfilled to hit
the breakpoint.

![Conditions can be set on basic breakpoints by right-clicking on it](images/conditional-contextual-menu-entries-on-basic-breakpoint.png)

Let's start with the _Condition_ contextual menu entry.

### The condition modifier

Click on the _Condition_ menu entry. You will be presented with the following
dialog box:

![A dialog box to set breakpoint conditions](images/breakpoint-condition-dialog-box.png)

As you can see from the previous screenshot, this dialog box contains one text
field where you can enter an expression that will be evaluated by the debugger
each time the next instruction pointer reaches the breakpoint's location.

If the "Is true" option is checked, the condition will need to evaluate to
_true_ for the breakpoint to match the condition. If the "Has changed" option
is checked, the expression will need to have changed from the previous
breakpoint hit to match the condition.

The format of the expression is limited, but still offers a lot of options.
Here are the rules you need to follow when writing the condition expression:

* Only C-style comparison operators are supported. These are _==_, _!=_, _<_, etc. Any comparison operator that can be used in your C/C++ code is supported.
* Methods or function calls are not supported. [Debugger intrinsics](#debugger-intrinsics) can help you mitigate this limitation. 
* Macros are not expanded, which means that you can't write _MY_MACRO_ within this text field and expect the evaluator to expand it. Instead, you'll need to use the actual value.

Besides these limitations, some useful tools are available when writing condition expressions:

* A complete set of debugger intrinsics functions, including a comprehensive list of string comparison functions, are available to use in the condition expression. To see the full list, head over to the [debugger intrinsics cheat sheet](#debugger-intrinsics).
* Specific debugger expressions starting with "$" or "@" named _pseudo registers_ that give you access to interesting values when debugging. For the full list of pseudo registers, please refer to the [pseudo registers cheat sheet](#pseudo-registers).

Let's try to use a simple conditional breakpoint. Enter the expression
_loopFoo % 2 == 0_ in the condition text field:

![Using simple comparison operators in breakpoints conditions](images/breakpoint-condition-modulo.png)

Notice how the breakpoint's icon's appearance changes. A white cross is now
visible in the middle of the red disk:

![A white cross appears in the middle of a breakpoint's icon if a condition is set](images/conditional-breakpoint-icon-with-cross.png)

A white cross means that one or more of the three conditional modifiers
(Condition, When hit or Filter) apply to a breakpoint.

Start debugging the program by pressing _F5_. The conditional breakpoint you
just set should hit five times, each time the variable _loopFoo_ is even.
Congratulations, you've just used your first advanced breakpoint!

Conditional breakpoints can be used anywhere, not just within loops. In the
same _Breakpoints_ project, add a breakpoint in _SomeClass_'s method named
_increaseSomeValue_:

![Setting a breakpoint in _SomeClass_' _increaseSomeValue_ method](images/breakpoint-someclass-increase-some-value.png)

Then, bring up the breakpoint modifiers contextual menu by right-clicking on
the newly added breakpoint and click on "Condition...". Then, within the
condition dialog's text input field, write the condition _m\_someValue == 1_:

![Conditional breakpoints can be set anywhere, not just within loops](images/breakpoint-someclass-increase-some-value-condition.png)

Finally, hit _F5_ to start debugging the program. The breakpoint you just set
should be hit. Hover with your mouse pointer on _m_someValue_'s declaration:
its value is 1, which corresponds to the breakpoint condition modifier we just
set. There's no constraint on where you can use breakpoints modifiers, including
condition modifiers.

#### Breaking only when some state changed

We haven't covered the "Has Changed" option of the "Condition" modifier dialog yet.

In the _Breakpoints_ project, add a new location breakpoint in the loop where
_foo_ is modified, and another one right after the end of the
loop, where _foo_ is assigned the value _42_:

![Setting up two conditional breakpoints to monitor changes made to _foo_.](images/condition-has-changed-breakpoint@300.png)

Set the same "Condition" modifier for both of them:

![Using the size format specifier and the "Has Changed" option to monitor changes made to a data buffer.](images/condition-has-changed-breakpoint-dialog@300.png)

If you look at the content of the variable _loopFoo_, you'll
see that the breakpoint triggered the second time that the CPU executed the
instruction at the address where it's located. Why didn't it trigger the first
time that the program wrote to _foo_?

The key concept here is that, with conditional breakpoints, we're still using
_location_ breakpoints. The way a conditional breakpoint using the "Has
Changed" option works is that, when the code at the breakpoint's location is
executed, the condition is evaluated. If this evaluation yelds a different
value than the previous one, the breakpoint triggers.

When the code reaches the breakpoint's location for the first time, there's no
previous evaluation against which to test the current evaluation, so the
breakpoint will not trigger.

For the same reason, if you disable the first conditional breakpoint we just
set and press F5, execution will continue without triggering the second
conditional breakpoint. Indeed, there's no chance that the CPU executes code
at this location more than once, so the conditional never has any chance to
trigger.

#### Watching large chunks of data

So far, we have shown how to trigger breakpoints when the next instruction
pointer reaches a given location, when some expression evaluates to true or
when the value of an expression changes.

However, these tools do not cover a typical use case when debugging programs:
watching _a large chunk of data_ and being notified when _any of its
elements_ changes.

It turns out that the "Has Changed" check box of the "Condition" modifier can
help us do that. The trick is to use it in conjunction with a _size format
specifier_.

In the _Breakpoints_ project, add a new location breakpoint in the loop where
_buffer_ is modified:

![Setting up a conditional breakpoint to monitor changes made to a data buffer.](images/condition-has-changed-breakpoint-size-format-specifier@300.png)

Set the "Condition" modifier:

![Using the size format specifier and the "Has Changed" option to monitor changes made to a data buffer.](images/condition-has-changed-breakpoint-size-format-specifier-dialog@300.png)

As you can see from the previous screenshot, the _,1024_ format specifier
means that the debugger will evaluate the 1024 items starting at _buffer_ and,
if any of them changes, will trigger the breakpoint.

Now start debugging the program by pressing F5. The conditional breakpoint
will be hit during the second iteration of the loop.

In some way, this section's title is a bit misleading. Conditional breakpoints
used in conjunction with size format specifiers do not allow to watch chunks
of data in memory at all times.

They can trigger only when the CPU executes the instruction at the
breakpoint's location, and they need the CPU to reach it at least twice.
However [data breakpoints](#data- breakpoints), the only way to watch for
memory writes at all times, have some serious limitations in terms of size and
number that make this solution the best tool available right now with Visual
C++'s debugger to monitor large chunks of data.

#### Exercice

In the _Breakpoints_ project, set a conditional breakpoint that breaks
everytime the _currentString_ variable holds the string _"foo"_. Hint: use
[debugger intrinsics](#debugger-intrinsics).

### The hit count modifier

Another way to implement a conditional breakpoint is to use the _Hit Count_
contextual menu entry of advanced breakpoints:

![Setting a hit count to create a conditional breakpoint](images/breakpoint-hit-count.png)

Delete the conditional breakpoint you created previously, and create another
breakpoint at the same location, in the for loop. Then click on the _Hit
Count_ contextual menu entry. You will be presented with the following dialog:

![Hit count breakpoint dialog](images/breakpoint-hit-count-dialog.png)

By default, this dialog is set to "Break always", which makes the breakpoint
act as a basic, location breakpoint. This setting is nonetheless already very
helpful, since the "Current hit count" label displays the number of times that
the breakpoint has been hit.

Click on the list box, and you'll see, in addition to the default "break
always" choice, three different hit count options:

![Different settings for hit count breakpoints](images/breakpoint-hit-count-dialog-expanded.png)

As you can see from this screenshot, a hit count breakpoint breaks the
debuggee when the next instruction pointer matches the breakpoint location,
_and_ it has been hit the number of times specified in the dialog box. A hit
count breakpoint is equivalent to a breakpoint with a condition modifier where
the condition would be true depending on the number of times the breakpoint
has been hit.

Here's a table that matches condition expressions with each hit
count setting available:

|Hit count setting     | Condition expression              |
|----------------------|-----------------------------------|
|break when the hit    | someVariable == desiredHitCount   |
|count is equal to     |                                   | 
|----------------------|-----------------------------------|
|break when the hit    |  someVariable % someMultiple == 0 |
|count is a multiple   |                                   |
|of                    |                                   |
|----------------------|-----------------------------------|
|break when the hit    | someVariable >= someHitCount      |
|count is greater than |                                   |
|or equal to           |                                   |

One might wonder why use the hit count modifier if the condition modifier can
achieve exactly the same thing, while allowing more flexibility. The reason
for using the hit count modifier over the condition modifier is there's no
need for a variable in your source code to hold the current hit count. This is
very handy when, for instance, during a debugging session, you want to break
depending on the hit count, but you can't change the source code without
stopping the program.[^edit-and-continue]

[^edit-and-continue]: It is sometimes possible to change your code during a debugging session without stopping the program by using the Edit & Continue feature. However, Edit & Continue has some serious limitations, and won't work in all cases.

#### The filter modifier

The filter modifier is the latest modifier that helps to create conditional
breakpoints. It allows programmers to trigger a breakpoint depending on the
following conditions:

* The current Windows machine name. 
* The current process id. Note that this is the debuggee's process id, not the debugger's process id. 
* The current thread id. As for the current process id, this is the debuggee's thread id, not the debugger thread id.
* The current thread name. As for the current thread id, this is the debuggee's thread name, not the debugger thread name. The thread name can be set programmatically. For more information about other advanced debugging tools when debugging multi-threaded programs, see the [Multi-threading advanced debug tools section](#multi-threading-advanced-debug-tools).

Individual conditions can be combined using logical operators _&_ (logical
and), _||_ (logical or) and _!_ (logical not).

### Combining modifiers

While individual modifiers are very helpful on their own, Visual C++'s
debugger allows you to mix and match them for greater flexibility. For
instance, you can set a condition, hit count and filter modifier at the same
time on any breakpoint. The modifiers will be combined using a logical _and_
operator, meaning that all modifiers will need to be satisfied in order for
the breakpoint to be triggered.

## Trace breakpoints

Trace breakpoints combine location breakpoints and the ability to output log
messages in Visual C++'s output window.

Location breakpoints pause the the debuggee's execution and allow programmers
to examine its current state. They give them all the time needed to to
inspect current variables' value, walk the callstack and browse the
debugee's memory. This is very powerful and, most of the time, it's sufficient
to find the solution to even complex bugs. However, once the debugee's
execution continues, all this information is lost. Without a way to keep a log
of the debuggee's state, some bugs can be very difficult to investigate.

This is where trace breakpoints can help. They allow you to output some debug
logs in the output window whenever a breakpoint is hit.

Let's use our _Breakpoints_ project to add a trace breakpoint that will output
some information when we call _SomeClass::increaseSomeValue_. As for all
breakpoint modifiers, you'll first need to create a "normal" or "location"
breakpoint in order to add a trace breakpoint. Then right-click the newly
created breakpoint and click on "When Hit...":

![Creating a trace breakpoint](images/trace-breakpoint-creation.png)

At that point, the following dialog will show:

![Trace breakpoint creation dialog](images/trace-breakpoint-creation-dialog.png)

In this dialog, you will need to check the _Print a message_ checkbox in order
to be able to specify what output log message to print when the breakpoint is
hit. When doing so, the online help will show you what syntax you can use to
display dynamic values, such as variables' values, the current callstack, the
caller, etc. Any expression that can be used in the [watch window](#watch-
window) can be used in this dialog's input field, including [pseudo-registers
](#pseudo-registers) and [format specifiers](#format- specifiers). For
instance, if you want to print the latest error code set with _SetLastError_,
simply enter _Latest error: {$err,hr}_ in the text field.

![Logging the latest error set by SetLastError using a trace point](images/trace-breakpoint-creation-dialog-output-message.png)

When a trace breakpoint is hit, its output is sent to the _Output_ window. The
output window can be displayed by clicking on the _DEBUG_ -> _Windows_ ->
_Output_ menu entry. Start debugging the project, and you should see the
following messages in the output window:

![Output messages logged using trace breakpoints are visible in the output window](images/trace-breakpoint-output-messages.png)

Note that it is possible to programmatically log messages in the output
window, without using trace breakpoints. In order to do this, you will need to
use the _OutputDebugString_ function covered in the [section about the
debugger's API](#debugger-api).

By default, trace breakpoints do not pause the debuggee's execution when hit.
In this case, they appear as a red diamond instead of a red circle. You can
make them pause the debuggee's by unchecking the "Continue execution"
checkbox:

![Setting a trace breakpoint to pause debuggee's execution](images/trace-breakpoint-creation-dialog-pause-execution.png)

When trace breakpoints pause the debuggee's execution, their appearance change
for a red circle, like for normal location breakpoints.

### A word about trace breakpoints' performance

Trace breakpoints are very usefull, and it can be tempting to use them instead
of writing extra logging code that has to be conditionnally deactivated for
production builds. However, trace breakpoints have a very significant impact
on performance. If they're hit very frequently (several times per second),
they will dramatically slow down your process, to the point where the
debuggee's becomes barely usable. The debugger and the whole system will also
take a big performance hit. Why is that?

Trace breakpoints are implemented the same way as any other "blocking"
breakpoint, except they don't wait for a user interaction to continue the
debuggee's execution. Each time the code at the trace breakpoint's location is
executed, the CPU emits the same debug event as when a normal location
breakpoint is hit. The operating system pauses the debuggee and send this
debug event to the debugger. This event is caught by the debugger, which
patches the debuggee's executable code[^debuggee-code- patching]. Then,
instead of waiting for the user to continue the debuggee's execution, the
debugger automatically performs a system call that continues the debuggee's
execution.

Hitting trace breakpoints very frequently adds a lot of context switching
between the debugger and the debuggee with a negative impact on their
performance.

[^debuggee-code-patching]: If you'd like to know more about what happens when a breakpoint is hit, go to the section entitled [How Visual C++'s debugger works](#how-visual-debugger-works).

### Combining trace breakpoints with conditional breakpoints

In the same way you can combine other modifiers, you can combine the _When
Hit_ modifier with all other modifiers to output some debug trace when your
conditional breakpoints are hit.

However, there's one drawback to this flexibility: setting many modifiers on a
breakpoint that is triggered very frequently (every second or more) can have a
big hit on the debuggee's performance. Using the minimum amount of modifiers
to solve your debugging challenges is a best practice that will help you keep
your debuggee's performance at a reasonnable level. It will make the debugging
experience all the more enjoyable.

## Data breakpoints {#data-breakpoints}

Data breakpoints, sometimes named memory breakpoints, are used to pause the
debuggee when a memory I/O operation is performed on a given range of its
address space. For instance, a data breakpoint can be set to pause the program
if four bytes of memory starting at address 0x07032345[^32-bits-address] are
written.

[^32-bits-address]: We're using a 32 bits address for convenience here, the address size depends on your target platform.

Data breakpoints are fundamentally different than traditional location
breakpoints. Instead of being hit when the next instruction to be executed
matches a given address, they can be triggered by any instruction of the
debuggee's code.

Usage of data breakpoints is appropriate when it's easier to reason about the
erroneous data rather than the code that causes it. Sometimes, the execution
paths that the code can take are well-known to us and identified, but its
output is wrong. In these cases, normal location breakpoints are handy because
they allow us to set check points at known code locations where we can check
inputs and outputs to finally pinpoint the source of the bug.

In other situations, code can take many different execution paths that are
still unknown to us, either because the code is very complex, or because  it's
not familiar to us. However, the erroneous data can be located very easily in
memory. Data breakpoints allow programmers to indicate the erroneous data's
address and find out which code path generates it.

The workflow to create data breakpoints is a bit different than to create
basic location breakpoints. Because data breakpoints are not attached to code,
they cannot be created in the code editor. Moreover, since they operate on the
debuggee's data addresses, the program to debug has to be started and its data
loaded in memory before they can be created.

To illustrate this, stop any ongoing debugging session in Visual C++. Make
sure the _Breakpoints_ project is loaded and hover on the _DEBUG_ -> _New
Breakpoint_ menu entry. The _New Data Breakpoint_ menu entry is disabled.

![The program to debug needs to be started before data breakpoints can be set](images/data-breakpoint-disabled-when-program-not-started.png)

Now, add a location breakpoint on the first line of the _main_'s function
implementation.

![Adding a breakpoint at the start of _main_'s function will allow us to set a
data breakpoint when the debuggee's data is loaded into its address
space](images/set-location-breakpoint-at-top-of-main.png)

Start debugging the program: the breakpoint you just set will
be hit. At that point, creating a data breakpoint is possible because the
debuggee's data is loaded in its address space.

![Creating a data breakpoint now that the debuggee's data is loaded](images/data-breakpoint-creation.png)

Another way to create a data breakpoint is to use the Breakpoints window
available via the _DEBUG_ -> _Windows_ -> _Breakpoints_ menu entry. Click on
the _New_ toolbar button and then on _New Data Breakpoint..._.

![Creating a data breakpoint from within the Breakpoints window](images/data-breakpoint-creation-alternate.png)

When creating a new data breakpoint, the following dialog appears:

![Data breakpoint creation dialog](images/data-breakpoint-creation-dialog.png)

This dialog contains two input text fields:

* The address of the first byte of data that will trigger the data breakpoint if a memory write operation is made. 
* The size in bytes of the memory area for which the data breakpoint will be valid.

By default, the size is set to four bytes. It is well suited for data types
for which _sizeof_ returns 4. However, you should change it if the data you're
monitoring has a different size. For instance, to trigger a breakpoint anytime
an ASCII character is changed, the size should be set to one byte. If you set
it to four bytes, it will trigger for characters that are adjacent in memory.

Let's set our new data breakpoint to trigger when the data represented by the
variable named _foo_ changes. To do that, enter the expression _&foo_ in the
_Address:_ input text field of the data breakpoint creation dialog. Since
_foo_ is of type _int_ and _sizeof(int)_ is four bytes on x86, the default
size of four bytes is fine.

![Setting the address for a new data breakpoint](images/data-breakpoint-creation-dialog-set-address.png)

The language input field is used as a label to later retrieve and sort your
breakpoints by programming language name. It doesn't have any impact on how
your data breakpoint behaves.

Click OK, and the _Breakpoints_ window should now list your new data breakpoint.

![The newly created data breakpoint has been added to the list of breakpoints
in the _Breakpoints_ window](images/data-breakpoint-added.png)

Note how its name differ from the location breakpoint we set earlier. The
location breakpoint's name mentions a line number, whereas the data breakpoint
mentions a memory address, and a data size. Now that the data breakpoint has
been set, continue the debuggee's execution by pressing _F5_.

Because the first instruction of the _main_ function initializes the variable
_foo_ with the value _0_, the data breakpoint triggers. Visual C++'s debugger
displays a modal dialog and the next instruction pointer points towards the
next instruction to be executed when the debuggee's execution continues.

![The data breakpoint is triggered for the first time, following the write of
the value 0 to the memory area represented by the variable _foo_](images/data-breakpoint-first-hit.png)

Now let's continue the debuggee's execution by pressing _F5_ again. What
happens is interesting: the breakpoint paused the program outside of _main_'s
implementation, where there's no breakpoint setup. 

![The data breakpoint is hit a second time outside of _main_'s
implementation](images/data-breakpoint-second-hit.png)

When we look at the callstack, the reason why the breakpoint triggered is
clear: _ChangeData_ wrote to the memory area represented by the variable
_foo_.

![The callstack at the time of the data breakpoint's second hit](images/data-breakpoint-second-hit-callstack.png)

If you continue pressing _F5_ to resume the debuggee's execution, the same
data breakpoint will be triggered every time some data is written to the
memory identified by _foo_, as expected.

### Choosing your data breakpoints' size carefully

Data breakpoints' size is four bytes by default. It works well for four-bytes
integer data like the data represented by the variable _foo_ in our
_Breakpoints_ project. However, choosing the right size for your data
breakpoints is key.

Let's re-use the data breakpoint that was created earlier and change its size
to one byte. In order to do so, stop the current debugging session and restart
it by pressing _F5_. The debugger should pause when hitting the location
breakpoint set at the beginning of _main_'s implementation. Go to the
_Breakpoints_ window by clicking on _DEBUG_ -> _Windows_ -> _Breakpoints_. The
data breakpoint created earlier is still present, but deactivated:

![Data breakpoints are deactivated upon restarting a debugging session](images/data-breakpoint-deactivated-after-restart.png)

Data breakpoints need to be re-enabled every time a debugging session starts.
Even worse, unless the _Randomized Base Address_ linker properties' option is
disabled (which is the case in our _Breakpoints_ project, but not by default),
any address that is referred to by the debugger will change between debugging
sessions. To learn more about these limitations and how to overcome it, at
least partially, go to the section entitled [Persistence accross debugging
sessions](#data-breakpoints-persistence-accross-debugging-sessions). For now,
let's just re-enable it and change its size to 1. In the same _Breakpoints_
window, right click on the disabled data breakpoint and click on
_Location..._:

![To edit a data breakpoint's address, click on Location...](images/data-breakpoint-edit-location.png)

The same dialog as when creating a new data breakpoint appears. Change the
"Byte count" input text field from 4 to 1:

![Changing a data breakpoint's size](images/data-breakpoint-edit-size.png)

Click OK and start debugging the program by pressing F5. The data breakpoint
should pause the debuggee in the same situations as before, including when
_ChangeData_ executes _data = 42;_. Now stop the debugger and change this line
of code from _data = 42;_ to _data = 0xFF000000;_. Restart the debugging
process (don't forget to re-enable the data breakpoint). The data breakpoint
triggers when initializing _foo_ to 0, but it doesn't trigger when calling
_ChangeData_. 

The reason is data breakpoints trigger _only when new data is written to a
memory address_. When _data = 0xFF000000;_ is executed, _data_ refers to the
same data as the _foo_ variable in the _main_ function's scope. _foo_ has
already been initialized to 0x00000000 (the 32 bits hexadecimal representation
of 0), and thus writing 0xFF000000 to it only changes the most significant
byte. Because the data breakpoint now triggers only if one byte changes, and
the Intel architecture is little-endian, the change to the most significant
byte of _foo_ does not trigger the data breakpoint.

Change the code to _data = 0x000000FF;_ in _ChangeData_'s implementation,
restart the debugging session and re-enable the data breakpoint: it will
trigger again when _ChangeData_ is called.

### Data breakpoints' limitations

Data breakpoints are very powerful and can help solving issues that standard
location breakpoints can't. However, because they're based on actual hardware,
they are by definition limited. This section presents these limitations and
how to work around them when possible.

#### Triggered only if data changes

One of the most counter-intuitive features of data breakpoints is that they're
triggered only when data changes, not when any write operation occurs.

#### Persistence accross debugging sessions {#data-breakpoints-persistence-accross-debugging-sessions}

Another irritating characteristic of data breakpoints is that they're always
disabled when a new debugging session starts. The reason is that most of the
time, data breakpoints are set on addresses that change every time the program
is executed. 

Indeed, you may set a data breakpoint on data that is stored in the process'
heap. Chances are that, during the next run of your program, data stored on
the heap will change. Any data breakpoint set previously is likely to point to
different or invalid data.

Another example is if you set a data breakpoint's to break when some global
data belonging to a DLL is changed. When this DLL is compiled with different
code  generation settings, chances are the address of the global data will
change, and your data breakpoints will not trigger as expected.

If that wasn't enough to convince you that adresses of objects in memory can
change between two debugging sessions, one of Window's security feature called
_ASLR_ (for _Address Space Layout Randomization_) randomizes the address space
of any process so that attackers can't easily guess the address of data when a
program runs. This means that every time a program is loaded into memory, no
memory address for any object is the same. Thus, any data breakpoint set
previously is invalid. This feature can be disabled if you want to avoid
resetting your data breakpoints' address every time a new debugging session
starts. Just go to your project's properties, click on "Configuration
Properties", "Linker", "Advanced" and  choose "No" for the "Randomized Base
Address" setting:

![Disabling Randomized Base Address for easier data breakpoints usage](images/disable-randomized-base-address.png)

As indicated in the screenshot, this configuration property can be set for
both optimized and unoptimized builds safely. However, make sure that your
product is not shipped with this setting enabled, as it would have a negative
impact on security.

The list of use cases that can invalidate data breakpoints' addresses is long,
so Visual C++'s developpers decided to disable data breakpoints by default
when a debugging session starts instead of anwsering countless support
requests by confused users.

#### Data breakpoints sometimes do not work as expected with optimized code

When compilers optimize code, one of their tool of choice is using the fastest
unit of hardware available to store data. This is why, in optmized builds, a
lot of data is stored in registers instead of in memory. The problem with this
approach when debugging is that the debugger cannot be notified when the
debuggee writes to a register. It can only be notified when the debuggee
writes to specific addresses in the main memory.

This issue happens only with intermediate data stored on the stack, not with
data that is stored on the heap and persists for longer than a function call.
For instance, you won't be able to set a data breakpoint on _foo_'s memory
address in a "Release" build of the "Breakpoints" project. Indeed, _foo_ has a
very short life and sits on the stack. However, allocating some data with
_malloc_ or _new_ and setting a data breakpoint on the returned address should
work reliably.

As a general rule, you should not use data breakpoints for short lived data
that is allocated on the stack. You shouldn't need it anyway, because the
location of the code that changes it should be easy to find in the function
where the data is used.  In these cases, it is most likely a sign that a
location breakpoint should be used, not a data breakpoint.

#### Number and size limitations {#data-breakpoints-size-and-number-limitation}

As mentionned in the previous section entitled [how data breakpoints work
](#how-data-breakpoints-work), data breakpoints are implemented using four
registers holding memory addresses to watch. Debug registers being pieces of
hardware, this number cannot be extended, and Visual C++'s debugger will show
an error dialog if you try to set more than four data breakpoints:

![Adding more than 4 data breakpoints results in an error.](images/data-breakpoints-limited-to-4.png)

Moreover, all other data breakpoints' settings, including the size of the
memory area for which to check write operations, are held in hardware
registers. For this reason, the size of the memory area that data breakpoints
can watch is limited to 4 bytes on the x86 platform, and 8 bytes on the x64
platform.

![Visual C++'s debugger cannot set data breakpoints with a size larger than 4 or 8 bytes depending on the platform.](images/data-breakpoint-too-large.png)

#### Only write operations trigger data breakpoints in Visual C++'s debugger

Although the Intel architecture supports data breakpoints that trigger on read
operations, Visual C++'s debugger only supports data breakpoints that trigger
on write operations. However, it is possible to set such data breakpoints
programmatically, by using the [_SetThreadContext_](http://msdn.microsoft.com/en-us/library/windows/desktop/ms680632%28v=vs.85%29.aspx) API. For more information on how to use this API, Michael Chourdakis has written [a concise tutorial on CodeProjet](http://www.codeproject.com/Articles/28071/Toggle-hardware-data-read-execute-breakpoints-prog?fid=1519331&fr=1&df=90&mpp=25&noise=3&prof=False&sort=Position&view=Normal&spc=Relaxed) with some sample code.

## Setting breakpoints programmatically {#setting-breakpoints-programmatically}

The latest type of breakpoints are breakpoints that are actually triggered by using the debugger's API.
There are three ways to use this API, and depending on the platforms, some of them are not available:

* Writing inline assembly to use the INT 3 instruction.
* Calling the _\_\_debugbreak_ intrinsic.
* Calling the _DebugBreak_ function.

### Using INT 3

This method is specific to the x86 platform. The reason for this limitation is
that using the _INT 3_ interrupt requires writing inline assembly, which is
not supported on the x86-64 platform[^inline-assembly-on-x86-64].

[^inline-assembly-on-x86-64]: Instead of using inline assembly, Microsoft suggests to use the compiler's equivalent intrinsics.

To see this type of breakpoint in action, open up the _Breakpoints_ project and 
uncomment the following line of code:

{title="Using inline assembly to trigger a breakpoint",lang=c++}
~~~ 
__asm int 3;
~~~

Start debugging the program and continue execution until the debugger breaks:

![The debugger breaks on a breakpoint set using inline assembly](images/inline-asm-breakpoint.png)

Now press Alt + 8 to go to the disassembly window to see what code was
generated by the _\_\_asm int 3;_ instruction:

![The disassembly window shows us what binary code was generated for the inline breakpoint.](images/inline-asm-breakpoint-disassembly.png)

Without too much surprise, the compiler generated the _0xCC_ opcode, the same
one used by Visual C++'s debugger to set new location breakpoints during
debugging sessions.

### Using the debugger's _\_\_debugbreak intrinsic

The x86-64 platform does not support inline assembly. However, programmers can
use Visual C++'s debugger's _\_\_debugbreak_ intrinsic to achieve the same
thing. Open up the _Breakpoints_ project and start a debugging session by pressing _F5_. Continue execution until the debugger breaks on the call to _\_\_debugbreak_:

![The debugger breaks on the _\_\_debugbreak_ intrinsic.](images/debugbreak-intrinsic.png)

Now, press Alt + 8 to display the disassembly window:

![The _\_\_debugbreak_ intrinsic generates the same INT 3 instruction used by the debugger to set location breakpoints.](images/debugbreak-intrinsic-disassembly.png)

Once again, when compiled, the _\_\_debugbreak_ intrinsics generates a _INT 3_
instruction, the same used by the debugger to implement location breakpoints.

### Using the _DebugBreak_ system function

The latest way to programmatically set a breakpoint is to use the _DebugBreak_ system function.
If the _Breakpoints_ project is still being debugged, simply continue the execution until you break on the call to _DebugBreak_:

![The debugger breaks on the call to the _DebugBreak_ system function.](images/debugbreak-function.png)

There is one difference between this method and the two previous ones: he debugger breaks _inside_ the call to _DebugBreak_, as the next call stack window's screenshot indicate.

![A screenshot of the callstack window when the debugger breaks because of call to _DebugBreak_.](images/debugbreak-function-callstack.png)
